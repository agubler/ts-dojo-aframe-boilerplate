(function (factory) {
    if (typeof module === 'object' && typeof module.exports === 'object') {
        var v = factory(require, exports); if (v !== undefined) module.exports = v;
    }
    else if (typeof define === 'function' && define.amd) {
        define(["require", "exports", './global', './has'], factory);
    }
})(function (require, exports) {
    "use strict";
    var global_1 = require('./global');
    var has_1 = require('./has');
    /**
     * Executes a task
     * @param item The task to execute
     */
    function executeTask(item) {
        if (item && item.isActive) {
            item.callback();
        }
    }
    /**
     * Get a handle to be able to remove an item from the queue
     */
    function getQueueHandle(item, destructor) {
        return {
            destroy: function () {
                this.destroy = function () { };
                if (item) {
                    item.isActive = false;
                }
                if (destructor) {
                    destructor();
                }
            }
        };
    }
    var microTasks = [];
    var microTaskQueued = false;
    var checkMicroTaskQueue = function () { };
    /**
     * Schedules a callback to the macrotask queue.
     *
     * @param callback the function to be queued and later executed.
     * @returns An object with a `destroy` method that, when called, prevents the registered callback from executing.
     */
    exports.queueTask = (function () {
        var destructor;
        var enqueue;
        /* IE and Edge's setImmediate does not always resolve as a macro task, sometimes as a microtask */
        if (has_1.default('postmessage')) {
            var queue_1 = [];
            addEventListener('message', function (event) {
                // Confirm that the event was triggered by the current window and by this particular implementation.
                if (event.source === global_1.default && event.data === 'dojo-queue-message') {
                    event.stopPropagation();
                    if (queue_1.length) {
                        executeTask(queue_1.shift());
                    }
                }
            });
            enqueue = function (item) {
                queue_1.push(item);
                postMessage('dojo-queue-message', '*');
            };
        }
        else if (has_1.default('setimmediate')) {
            destructor = clearImmediate;
            enqueue = function (item) {
                return setImmediate(executeTask.bind(null, item));
            };
        }
        else {
            destructor = clearTimeout;
            enqueue = function (item) {
                return setTimeout(executeTask.bind(null, item), 0);
            };
        }
        function queueTask(callback) {
            var item = {
                isActive: true,
                callback: callback
            };
            var id = enqueue(item);
            return getQueueHandle(item, destructor && function () {
                destructor(id);
            });
        }
        ;
        // TODO: Use aspect.before when it is available.
        return has_1.default('microtasks') ? queueTask : function (callback) {
            checkMicroTaskQueue();
            return queueTask(callback);
        };
    })();
    checkMicroTaskQueue = !has_1.default('microtasks')
        ? function () {
            if (!microTaskQueued) {
                microTaskQueued = true;
                exports.queueTask(function () {
                    microTaskQueued = false;
                    if (microTasks.length) {
                        var item = void 0;
                        while (item = microTasks.shift()) {
                            executeTask(item);
                        }
                    }
                });
            }
        } : checkMicroTaskQueue;
    /**
     * Schedules a callback to the microtask queue.
     *
     * Any callbacks registered with `queueMicroTask` will be executed before the next macrotask. If no native
     * mechanism for scheduling macrotasks is exposed, then any callbacks will be fired before any macrotask
     * registered with `queueTask` or `queueAnimationTask`.
     *
     * @param callback the function to be queued and later executed.
     * @returns An object with a `destroy` method that, when called, prevents the registered callback from executing.
     */
    exports.queueMicroTask = (function () {
        var enqueue;
        if (has_1.default('host-node')) {
            enqueue = function (item) {
                process.nextTick(executeTask.bind(null, item));
            };
        }
        else if (has_1.default('es6-promise') && !has_1.default('setimmediate') && !has_1.default('host-node')) {
            enqueue = function (item) {
                global_1.default.Promise.resolve(item).then(executeTask);
            };
        }
        else if (has_1.default('dom-mutationobserver')) {
            /* tslint:disable-next-line:variable-name */
            var HostMutationObserver = global_1.default.MutationObserver || global_1.default.WebKitMutationObserver;
            var node_1 = document.createElement('div');
            var queue_2 = [];
            var observer = new HostMutationObserver(function () {
                while (queue_2.length > 0) {
                    var item = queue_2.shift();
                    if (item && item.isActive) {
                        item.callback();
                    }
                }
            });
            observer.observe(node_1, { attributes: true });
            enqueue = function (item) {
                queue_2.push(item);
                node_1.setAttribute('queueStatus', '1');
            };
        }
        else {
            enqueue = function (item) {
                checkMicroTaskQueue();
                microTasks.push(item);
            };
        }
        return function (callback) {
            var item = {
                isActive: true,
                callback: callback
            };
            enqueue(item);
            return getQueueHandle(item);
        };
    })();
});
//# sourceMappingURL=queue.js.map