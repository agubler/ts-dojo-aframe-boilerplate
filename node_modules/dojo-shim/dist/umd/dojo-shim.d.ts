declare module 'dojo-shim/support/global' {
	 const globalObject: any;
	export default globalObject;

}
declare module 'dojo-shim/support/has' {
	import has from 'dojo-has/has';
	export default has;
	export * from 'dojo-has/has';

}
declare module 'dojo-shim/support/util' {
	/**
	 * Helper function to generate a value property descriptor
	 *
	 * @param value        The value the property descriptor should be set to
	 * @param enumerable   If the property should be enumberable, defaults to false
	 * @param writable     If the property should be writable, defaults to true
	 * @param configurable If the property should be configurable, defaults to true
	 * @return             The property descriptor object
	 */
	export function getValueDescriptor<T>(value: T, enumerable?: boolean, writable?: boolean, configurable?: boolean): TypedPropertyDescriptor<T>;
	/**
	 * A helper function which wraps a function where the first argument becomes the scope
	 * of the call
	 *
	 * @param nativeFunction The source function to be wrapped
	 */
	export function wrapNative(nativeFunction: Function): any;

}
declare module 'dojo-shim/interfaces' {
	/**
	 * Thenable represents any object with a callable `then` property.
	 */
	export interface Thenable<T> {
	    then<U>(onFulfilled?: (value?: T) => U | Thenable<U>, onRejected?: (error?: any) => U | Thenable<U>): Thenable<U>;
	    then<U>(onFulfilled?: (value?: T) => U | Thenable<U>, onRejected?: (error?: any) => void): Thenable<U>;
	}
	export interface ArrayLike<T> {
	    length: number;
	    [n: number]: T;
	}

}
declare module 'dojo-shim/string' {
	/**
	 * The minimum location of high surrogates
	 */
	export const HIGH_SURROGATE_MIN: number;
	/**
	 * The maximum location of high surrogates
	 */
	export const HIGH_SURROGATE_MAX: number;
	/**
	 * The minimum location of low surrogates
	 */
	export const LOW_SURROGATE_MIN: number;
	/**
	 * The maximum location of low surrogates
	 */
	export const LOW_SURROGATE_MAX: number;
	export namespace Shim {
	    function raw(callSite: TemplateStringsArray, ...substitutions: any[]): string;
	    function fromCodePoint(...codePoints: number[]): string;
	    function codePointAt(text: string, position?: number): number | undefined;
	    function repeat(text: string, count?: number): string;
	    function startsWith(text: string, search: string, position?: number): boolean;
	    function endsWith(text: string, search: string, endPosition?: number): boolean;
	    function includes(text: string, search: string, position?: number): boolean;
	}
	/**
	 * A tag function for template strings to get the template string's raw string form.
	 *
	 * @param callSite Call site object (or a template string in TypeScript, which will transpile to one)
	 * @param substitutions Values to substitute within the template string (TypeScript will generate these automatically)
	 * @return String containing the raw template string with variables substituted
	 *
	 * @example
	 * // Within TypeScript; logs 'The answer is:\\n42'
	 * let answer = 42;
	 * console.log(string.raw`The answer is:\n${answer}`);
	 *
	 * @example
	 * // The same example as above, but directly specifying a JavaScript object and substitution
	 * console.log(string.raw({ raw: [ 'The answer is:\\n', '' ] }, 42));
	 */
	export const raw: (callSite: TemplateStringsArray, ...substitutions: any[]) => string;
	/**
	 * Returns the UTF-16 encoded code point value of a given position in a string.
	 *
	 * @param text The string containing the element whose code point is to be determined
	 * @param position Position of an element within the string to retrieve the code point value from
	 * @return A non-negative integer representing the UTF-16 encoded code point value
	 */
	export const fromCodePoint: (...codePoints: number[]) => string;
	/**
	 * Returns the UTF-16 encoded code point value of a given position in a string.
	 *
	 * @param text The string containing the element whose code point is to be determined
	 * @param position Position of an element within the string to retrieve the code point value from
	 * @return A non-negative integer representing the UTF-16 encoded code point value
	 */
	export const codePointAt: (text: string, position?: number) => number;
	/**
	 * Returns a string containing the given string repeated the specified number of times.
	 *
	 * @param text The string to repeat
	 * @param count The number of times to repeat the string
	 * @return A string containing the input string repeated count times
	 */
	export const repeat: (text: string, count?: number) => string;
	/**
	 * Determines whether a string begins with the given substring (optionally starting from a given index).
	 *
	 * @param text The string to look for the search string within
	 * @param search The string to search for
	 * @param position The index to begin searching at
	 * @return Boolean indicating if the search string was found at the beginning of the given string
	 */
	export const startsWith: (text: string, search: string, position?: number) => boolean;
	/**
	 * Determines whether a string ends with the given substring.
	 *
	 * @param text The string to look for the search string within
	 * @param search The string to search for
	 * @param endPosition The index searching should stop before (defaults to text.length)
	 * @return Boolean indicating if the search string was found at the end of the given string
	 */
	export const endsWith: (text: string, search: string, endPosition?: number) => boolean;
	/**
	 * Determines whether a string includes the given substring (optionally starting from a given index).
	 *
	 * @param text The string to look for the search string within
	 * @param search The string to search for
	 * @param position The index to begin searching at
	 * @return Boolean indicating if the search string was found within the given string
	 */
	export const includes: (text: string, search: string, position?: number) => boolean;

}
declare module 'dojo-shim/Symbol' {
	export namespace Shim {
	    /**
	     * A custom guard function that determines if an object is a symbol or not
	     * @param  {any}       value The value to check to see if it is a symbol or not
	     * @return {is symbol}       Returns true if a symbol or not (and narrows the type guard)
	     */
	    function isSymbol(value: any): value is symbol;
	    const Exposed: SymbolConstructor;
	} const SymbolShim: SymbolConstructor;
	export const isSymbol: typeof Shim.isSymbol;
	export default SymbolShim;

}
declare module 'dojo-shim/iterator' {
	import { ArrayLike } from 'dojo-shim/interfaces';
	import 'dojo-shim/Symbol';
	export interface IteratorResult<T> {
	    done: boolean;
	    value: T;
	}
	export interface Iterator<T> {
	    next(value?: any): IteratorResult<T>;
	    return?(value?: any): IteratorResult<T>;
	    throw?(e?: any): IteratorResult<T>;
	}
	export interface Iterable<T> {
	    [Symbol.iterator](): Iterator<T>;
	}
	export interface IterableIterator<T> extends Iterator<T> {
	    [Symbol.iterator](): IterableIterator<T>;
	}
	/**
	 * A class that provides "shims" an iterator interface on array like
	 * objects.
	 */
	export class ShimIterator<T> {
	    private _list;
	    private _nextIndex;
	    private _nativeIterator;
	    constructor(list: ArrayLike<T> | Iterable<T>);
	    /**
	     * Return the next iteration result for the Iterator
	     */
	    next(): IteratorResult<T>;
	    [Symbol.iterator](): IterableIterator<T>;
	}
	/**
	 * A type guard for checking if something has an Iterable interface
	 *
	 * @param value The value to type guard against
	 */
	export function isIterable(value: any): value is Iterable<any>;
	/**
	 * A type guard for checking if something is ArrayLike
	 *
	 * @param value The value to type guard against
	 */
	export function isArrayLike(value: any): value is ArrayLike<any>;
	/**
	 * Returns the iterator for an object
	 *
	 * @param iterable The iterable object to return the iterator for
	 */
	export function get<T>(iterable: Iterable<T> | ArrayLike<T>): Iterator<T> | undefined;
	export interface ForOfCallback<T> {
	    /**
	     * A callback function for a forOf() iteration
	     *
	     * @param value The current value
	     * @param object The object being iterated over
	     * @param doBreak A function, if called, will stop the iteration
	     */
	    (value: T, object: Iterable<T> | ArrayLike<T> | string, doBreak: () => void): void;
	}
	/**
	 * Shims the functionality of `for ... of` blocks
	 *
	 * @param iterable The object the provides an interator interface
	 * @param callback The callback which will be called for each item of the iterable
	 * @param thisArg Optional scope to pass the callback
	 */
	export function forOf<T>(iterable: Iterable<T> | ArrayLike<T> | string, callback: ForOfCallback<T>, thisArg?: any): void;

}
declare module 'dojo-shim/number' {
	/**
	 * The smallest interval between two representable numbers.
	 */
	export const EPSILON: number;
	/**
	 * The maximum safe integer in JavaScript
	 */
	export const MAX_SAFE_INTEGER: number;
	/**
	 * The minimum safe integer in JavaScript
	 */
	export const MIN_SAFE_INTEGER: number;
	/**
	 * Determines whether the passed value is NaN without coersion.
	 *
	 * @param value The value to test
	 * @return true if the value is NaN, false if it is not
	 */
	export function isNaN(value: any): boolean;
	/**
	 * Determines whether the passed value is a finite number without coersion.
	 *
	 * @param value The value to test
	 * @return true if the value is finite, false if it is not
	 */
	export function isFinite(value: any): boolean;
	/**
	 * Determines whether the passed value is an integer.
	 *
	 * @param value The value to test
	 * @return true if the value is an integer, false if it is not
	 */
	export function isInteger(value: any): boolean;
	/**
	 * Determines whether the passed value is an integer that is 'safe,' meaning:
	 *   1. it can be expressed as an IEEE-754 double precision number
	 *   2. it has a one-to-one mapping to a mathematical integer, meaning its
	 *      IEEE-754 representation cannot be the result of rounding any other
	 *      integer to fit the IEEE-754 representation
	 *
	 * @param value The value to test
	 * @return true if the value is an integer, false if it is not
	 */
	export function isSafeInteger(value: any): boolean;

}
declare module 'dojo-shim/array' {
	import { ArrayLike } from 'dojo-shim/interfaces';
	import { Iterable } from 'dojo-shim/iterator';
	export interface MapCallback<T, U> {
	    /**
	     * A callback function when mapping
	     *
	     * @param element The element that is currently being mapped
	     * @param index The current index of the element
	     */
	    (element: T, index: number): U;
	}
	export interface FindCallback<T> {
	    /**
	     * A callback function when using find
	     *
	     * @param element The element that is currenty being analysed
	     * @param index The current index of the element that is being analysed
	     * @param array The source array
	     */
	    (element: T, index: number, array: ArrayLike<T>): boolean;
	}
	/**
	 * A namespace that contains the polyfilled functionality that is then exported below, depending on if
	 * the functionality is required or not.
	 */
	export namespace Shim {
	    function from(this: ArrayConstructor, arrayLike: Iterable<any> | ArrayLike<any>, mapFunction?: MapCallback<any, any>, thisArg?: any): Array<any>;
	    function of<T>(...items: T[]): Array<T>;
	    function copyWithin<T>(target: ArrayLike<T>, offset: number, start: number, end?: number): ArrayLike<T>;
	    function fill<T>(target: ArrayLike<T>, value: any, start?: number, end?: number): ArrayLike<T>;
	    function find<T>(target: ArrayLike<T>, callback: FindCallback<T>, thisArg?: {}): T | undefined;
	    function findIndex<T>(target: ArrayLike<T>, callback: FindCallback<T>, thisArg?: {}): number;
	    function includes<T>(target: ArrayLike<T>, searchElement: T, fromIndex?: number): boolean;
	}
	export interface From {
	    /**
	     * The Array.from() method creates a new Array instance from an array-like or iterable object.
	     *
	     * @param arrayLike An array-like object to convert to an array
	     * @param mapFunction A map function to call on each element in the array
	     * @param thisArg The execution context for the map function
	     * @return The new Array
	     */
	    <T, U>(arrayLike: ArrayLike<T>, mapFunction: MapCallback<T, U>, thisArg?: any): Array<U>;
	    /**
	     * The Array.from() method creates a new Array instance from an array-like or iterable object.
	     *
	     * @param iterable An iterable object to convert to an array
	     * @param mapFunction A map function to call on each element in the array
	     * @param thisArg The execution context for the map function
	     * @return The new Array
	     */
	    <T, U>(iterable: Iterable<T>, mapFunction: MapCallback<T, U>, thisArg?: any): Array<U>;
	    /**
	     * The Array.from() method creates a new Array instance from an array-like or iterable object.
	     *
	     * @param arrayLike An array-like object to convert to an array
	     * @return The new Array
	     */
	    <T>(arrayLike: ArrayLike<T>): Array<T>;
	    /**
	     * The Array.from() method creates a new Array instance from an array-like or iterable object.
	     *
	     * @param arrayLike An iterable object to convert to an array
	     * @return The new Array
	     */
	    <T>(iterable: Iterable<T>): Array<T>;
	}
	export const from: From;
	/**
	 * Creates a new array from the function parameters.
	 *
	 * @param arguments Any number of arguments for the array
	 * @return An array from the given arguments
	 */
	export const of: <T>(...items: T[]) => Array<T>;
	/**
	 * Copies data internally within an array or array-like object.
	 *
	 * @param target The target array-like object
	 * @param offset The index to start copying values to; if negative, it counts backwards from length
	 * @param start The first (inclusive) index to copy; if negative, it counts backwards from length
	 * @param end The last (exclusive) index to copy; if negative, it counts backwards from length
	 * @return The target
	 */
	export const copyWithin: <T>(target: ArrayLike<T>, offset: number, start: number, end?: number) => ArrayLike<T>;
	/**
	 * Fills elements of an array-like object with the specified value.
	 *
	 * @param target The target to fill
	 * @param value The value to fill each element of the target with
	 * @param start The first index to fill
	 * @param end The (exclusive) index at which to stop filling
	 * @return The filled target
	 */
	export const fill: <T>(target: ArrayLike<T>, value: T, start?: number, end?: number) => ArrayLike<T>;
	/**
	 * Finds and returns the first instance matching the callback or undefined if one is not found.
	 *
	 * @param target An array-like object
	 * @param callback A function returning if the current value matches a criteria
	 * @param [thisArg] The execution context for the find function
	 * @return The first element matching the callback, or undefined if one does not exist
	 */
	export const find: <T>(target: ArrayLike<T>, callback: FindCallback<T>, thisArg?: {}) => T;
	/**
	 * Performs a linear search and returns the first index whose value satisfies the passed callback,
	 * or -1 if no values satisfy it.
	 *
	 * @param target An array-like object
	 * @param callback A function returning true if the current value satisfies its criteria
	 * @param [thisArg] The execution context for the find function
	 * @return The first index whose value satisfies the passed callback, or -1 if no values satisfy it
	 */
	export const findIndex: <T>(target: ArrayLike<T>, callback: FindCallback<T>, thisArg?: {}) => number;
	/**
	 * Determines whether an array includes a given value
	 *
	 * @param target the target array-like object
	 * @param searchElement the item to search for
	 * @param fromIndex the starting index to search from
	 * @return `true` if the array includes the element, otherwise `false`
	 */
	export const includes: <T>(target: ArrayLike<T>, searchElement: T, fromIndex?: number) => boolean;

}
declare module 'dojo-shim/support/decorators' {
	/**
	 * A class decorator that provides either a native class or a shimmed class based on a feature
	 * test
	 * @param feature The has feature to check
	 * @param trueClass The class to use if feature test returns `true`
	 * @param falseClass The class to use if the feature test returns `false` or is not defined
	 */
	export function hasClass(feature: string, trueClass: Function, falseClass: Function): ClassDecorator;

}
declare module 'dojo-shim/object' {
	import 'dojo-shim/Symbol';
	/**
	 * Determines whether two values are the same value.
	 *
	 * @param value1 The first value to compare
	 * @param value2 The second value to compare
	 * @return true if the values are the same; false otherwise
	 */
	export const is: (value1: any, value2: any) => boolean;
	/**
	 * Returns an array of own properties who key is a symbol
	 *
	 * @param o The object to return the properties for
	 */
	export const getOwnPropertySymbols: (o: any) => symbol[];
	/**
	 * Returns an array of own properties who key is a string
	 *
	 * @param o The object to return the properties for
	 */
	export const getOwnPropertyNames: (o: any) => string[];

}
declare module 'dojo-shim/Map' {
	import { ArrayLike } from 'dojo-shim/interfaces';
	import { Iterable, IterableIterator } from 'dojo-shim/iterator';
	import 'dojo-shim/Symbol';
	export namespace Shim {
	    /**
	     * An implementation analogous to the Map specification in ES2015.
	     */
	    class Map<K, V> {
	        protected _keys: K[];
	        protected _values: V[];
	        /**
	         * An alternative to Array.prototype.indexOf using Object.is
	         * to check for equality. See http://mzl.la/1zuKO2V
	         */
	        protected _indexOfKey(keys: K[], key: K): number;
	        /**
	         * Creates a new Map
	         *
	         * @constructor
	         *
	         * @param iterator
	         * Array or iterator containing two-item tuples used to initially populate the map.
	         * The first item in each tuple corresponds to the key of the map entry.
	         * The second item corresponds to the value of the map entry.
	         */
	        constructor(iterable?: ArrayLike<[K, V]> | Iterable<[K, V]>);
	        /**
	         * Returns the number of key / value pairs in the Map.
	         *
	         * @return the number of key / value pairs in the Map
	         */
	        readonly size: number;
	        /**
	         * Deletes all keys and their associated values.
	         */
	        clear(): void;
	        /**
	         * Deletes a given key and its associated value.
	         *
	         * @param key The key to delete
	         * @return true if the key exists, false if it does not
	         */
	        delete(key: K): boolean;
	        /**
	         * Returns an iterator that yields each key/value pair as an array.
	         *
	         * @return An iterator for each key/value pair in the instance.
	         */
	        entries(): IterableIterator<[K, V]>;
	        /**
	         * Executes a given function for each map entry. The function
	         * is invoked with three arguments: the element value, the
	         * element key, and the associated Map instance.
	         *
	         * @param callback The function to execute for each map entry,
	         * @param context The value to use for `this` for each execution of the calback
	         */
	        forEach(callback: (value: V, key: K, mapInstance: Map<K, V>) => any, context?: {}): void;
	        /**
	         * Returns the value associated with a given key.
	         *
	         * @param key The key to look up
	         * @return The value if one exists or undefined
	         */
	        get(key: K): V | undefined;
	        /**
	         * Checks for the presence of a given key.
	         *
	         * @param key The key to check for
	         * @return true if the key exists, false if it does not
	         */
	        has(key: K): boolean;
	        /**
	         * Returns an iterator that yields each key in the map.
	         *
	         * @return An iterator containing the instance's keys.
	         */
	        keys(): IterableIterator<K>;
	        /**
	         * Sets the value associated with a given key.
	         *
	         * @param key The key to define a value to
	         * @param value The value to assign
	         * @return The Map instance
	         */
	        set(key: K, value: V): Map<K, V>;
	        /**
	         * Returns an iterator that yields each value in the map.
	         *
	         * @return An iterator containing the instance's values.
	         */
	        values(): IterableIterator<V>;
	        [Symbol.iterator](): IterableIterator<[K, V]>;
	        [Symbol.toStringTag]: string;
	    }
	}
	export default class Map<K, V> {
	    constructor(iterable?: ArrayLike<[K, V]> | Iterable<[K, V]>);
	    readonly size: number;
	    clear(): void;
	    delete(key: K): boolean;
	    entries(): IterableIterator<[K, V]>;
	    forEach(callback: (value: V, key: K, mapInstance: Map<K, V>) => any, context?: {}): void;
	    get(key: K): V | undefined;
	    has(key: K): boolean;
	    keys(): IterableIterator<K>;
	    set(key: K, value: V): Map<K, V>;
	    values(): IterableIterator<V>;
	    [Symbol.iterator](): IterableIterator<[K, V]>;
	    [Symbol.toStringTag]: string;
	}

}
declare module 'dojo-shim/math' {
	export namespace Shim {
	    function acosh(n: number): number;
	    function asinh(n: number): number;
	    function atanh(n: number): number;
	    function cbrt(n: number): number;
	    function clz32(n: number): number;
	    function cosh(n: number): number;
	    function expm1(n: number): number;
	    const fround: (n: number) => number;
	    function hypot(...args: number[]): number;
	    function imul(n: number, m: number): number;
	    function log2(n: number): number;
	    function log10(n: number): number;
	    function log1p(n: number): number;
	    function sign(n: number): number;
	    function sinh(n: number): number;
	    function tanh(n: number): number;
	    function trunc(n: number): number;
	}
	/**
	 * Returns the hyperbolic arccosine of a number.
	 *
	 * @param n The number to use in calculation
	 * @return The result
	 */
	export const acosh: (n: number) => number;
	/**
	 * Returns the hyperbolic arcsine of a number.
	 *
	 * @param n The number to use in calculation
	 * @return The result
	 */
	export const asinh: (n: number) => number;
	/**
	 * Returns the hyperbolic arctangent of a number.
	 *
	 * @param n The number to use in calculation
	 * @return The result
	 */
	export const atanh: (n: number) => number;
	/**
	 * Returns the cube root of a number.
	 *
	 * @param n The number to use in calculation
	 * @return The result
	 */
	export const cbrt: (n: number) => number;
	/**
	 * Returns the number of leading zero bits in the 32-bit
	 * binary representation of a number.
	 *
	 * @param n The number to use in calculation
	 * @return The result
	 */
	export const clz32: (n: number) => number;
	/**
	 * Returns the hyperbolic cosine of a number.
	 *
	 * @param n The number to use in calculation
	 * @return The result
	 */
	export const cosh: (n: number) => number;
	/**
	 * Returns e raised to the specified power minus one.
	 *
	 * @param n The number to use in calculation
	 * @return The result
	 */
	export const expm1: (n: number) => number;
	/**
	 * Returns the nearest single-precision float representation of a number.
	 *
	 * @param n The number to use in calculation
	 * @return The result
	 */
	export const fround: (n: number) => number;
	/**
	 * Returns the square root of the sum of squares of its arguments.
	 *
	 * @return The result
	 */
	export const hypot: (...args: number[]) => number;
	/**
	 * Returns the result of the 32-bit multiplication of the two parameters.
	 *
	 * @param n The number to use in calculation
	 * @param m The number to use in calculation
	 * @return The result
	 */
	export const imul: (n: number, m: number) => number;
	/**
	 * Returns the base 2 logarithm of a number.
	 *
	 * @param n The number to use in calculation
	 * @return The result
	 */
	export const log2: (n: number) => number;
	/**
	 * Returns the base 10 logarithm of a number.
	 *
	 * @param n The number to use in calculation
	 * @return The result
	 */
	export const log10: (n: number) => number;
	/**
	 * Returns the natural logarithm of 1 + a number.
	 *
	 * @param n The number to use in calculation
	 * @return The result
	 */
	export const log1p: (n: number) => number;
	/**
	 * Returns the sign of a number, indicating whether the number is positive.
	 *
	 * @param n The number to use in calculation
	 * @return 1 if the number is positive, -1 if the number is negative, or 0 if the number is 0
	 */
	export const sign: (n: number) => number;
	/**
	 * Returns the hyperbolic sine of a number.
	 *
	 * @param n The number to use in calculation
	 * @return The result
	 */
	export const sinh: (n: number) => number;
	/**
	 * Returns the hyperbolic tangent of a number.
	 *
	 * @param n The number to use in calculation
	 * @return The result
	 */
	export const tanh: (n: number) => number;
	/**
	 * Returns the integral part of a number by removing any fractional digits.
	 *
	 * @param n The number to use in calculation
	 * @return The result
	 */
	export const trunc: (n: number) => number;

}
declare module 'dojo-shim/Set' {
	import { ArrayLike } from 'dojo-shim/interfaces';
	import { IterableIterator, Iterable } from 'dojo-shim/iterator';
	import 'dojo-shim/Symbol';
	export namespace Shim {
	    class Set<T> {
	        private _setData;
	        constructor(iterable?: ArrayLike<T> | Iterable<T>);
	        add(value: T): this;
	        clear(): void;
	        delete(value: T): boolean;
	        entries(): IterableIterator<[T, T]>;
	        forEach(callbackfn: (value: T, index: T, set: Set<T>) => void, thisArg?: any): void;
	        has(value: T): boolean;
	        keys(): IterableIterator<T>;
	        readonly size: number;
	        values(): IterableIterator<T>;
	        [Symbol.iterator](): IterableIterator<T>;
	        [Symbol.toStringTag]: string;
	    }
	}
	export default class Set<T> {
	    constructor(iterable?: ArrayLike<T> | Iterable<T>);
	    add(value: T): this;
	    clear(): void;
	    delete(value: T): boolean;
	    entries(): IterableIterator<[T, T]>;
	    forEach(callbackfn: (value: T, index: T, set: Set<T>) => void, thisArg?: any): void;
	    has(value: T): boolean;
	    keys(): IterableIterator<T>;
	    readonly size: number;
	    values(): IterableIterator<T>;
	    [Symbol.iterator](): IterableIterator<T>;
	    [Symbol.toStringTag]: string;
	}

}
declare module 'dojo-shim/WeakMap' {
	import { ArrayLike } from 'dojo-shim/interfaces';
	import { Iterable } from 'dojo-shim/iterator';
	import 'dojo-shim/Symbol';
	export default class WeakMap<K, V> {
	    constructor(iterable?: ArrayLike<[K, V]> | Iterable<[K, V]>);
	    delete(key: K): boolean;
	    get(key: K): V;
	    has(key: K): boolean;
	    set(key: K, value?: V): WeakMap<K, V>;
	    [Symbol.toStringTag]: string;
	}

}
declare module 'dojo-shim/main' {
	import * as array from 'dojo-shim/array';
	import * as iterator from 'dojo-shim/iterator';
	import Map from 'dojo-shim/Map';
	import * as math from 'dojo-shim/math';
	import * as number from 'dojo-shim/number';
	import * as object from 'dojo-shim/object';
	import Set from 'dojo-shim/Set';
	import * as string from 'dojo-shim/string';
	import Symbol from 'dojo-shim/Symbol';
	import WeakMap from 'dojo-shim/WeakMap';
	export { array, iterator, Map, math, number, object, Set, string, Symbol, WeakMap };

}
declare module 'dojo-shim/native/iterator' {
	export interface IteratorResult<T> {
	    done: boolean;
	    value?: T;
	}
	export interface Iterator<T> {
	    next(value?: any): IteratorResult<T>;
	    return?(value?: any): IteratorResult<T>;
	    throw?(e?: any): IteratorResult<T>;
	}
	export interface Iterable<T> {
	    [Symbol.iterator](): Iterator<T>;
	}
	export interface IterableIterator<T> extends Iterator<T> {
	    [Symbol.iterator](): IterableIterator<T>;
	}
	/**
	 * A type guard for checking if something has an Iterable interface
	 * @param value The value to type guard against
	 */
	export function isIterable(value: any): value is Iterable<any>;
	/**
	 * A type guard for checking if something is ArrayLike
	 * @param value The value to type guard against
	 */
	export function isArrayLike(value: any): value is ArrayLike<any>;
	/**
	 * Returns the iterator for an object
	 *
	 * @param iterable The iterable object to return the iterator for
	 */
	export function get<T>(iterable: Iterable<T> | ArrayLike<T> | string): Iterator<T> | undefined;
	export interface ForOfCallback<T> {
	    /**
	     * A callback function for a forOf() iteration
	     *
	     * @param value The current value
	     * @param object The object being iterated over
	     * @param doBreak A function, if called, will stop the iteration
	     */
	    (value: T, object: Iterable<T> | ArrayLike<T> | string, doBreak: () => void): void;
	}
	/**
	 * Shims the functionality of `for ... of` blocks
	 *
	 * @param iterable The object the provides an interator interface
	 * @param callback The callback which will be called for each item of the iterable
	 * @param thisArg Optional scope to pass the callback
	 */
	export function forOf<T>(iterable: Iterable<T> | ArrayLike<T> | string, callback: ForOfCallback<T>, thisArg?: any): void;

}
declare module 'dojo-shim/native/array' {
	import { Iterable } from 'dojo-shim/native/iterator';
	export interface MapCallback<T> {
	    /**
	     * A callback function when mapping
	     *
	     * @param element The element that is currently being mapped
	     * @param index The current index of the element
	     */
	    (element: T, index: number): T;
	}
	export interface FindCallback<T> {
	    /**
	     * A callback function when using find
	     *
	     * @param element The element that is currenty being analysed
	     * @param index The current index of the element that is being analysed
	     * @param array The source array
	     */
	    (element: T, index: number, array: ArrayLike<T>): boolean;
	}
	export interface From {
	    (arrayLike: string, mapFunction?: MapCallback<string>, thisArg?: {}): Array<string>;
	    <T>(arrayLike: Iterable<T> | ArrayLike<T>, mapFunction?: MapCallback<T>, thisArg?: {}): Array<T>;
	    /**
	     * The Array.from() method creates a new Array instance from an array-like or iterable object.
	     *
	     * @param arrayLike An array-like or iterable object to convert to an array
	     * @param mapFunction A map function to call on each element in the array
	     * @param thisArg The execution context for the map function
	     * @return The new Array
	     */
	    <T>(arrayLike: (string | Iterable<T> | ArrayLike<T>), mapFunction?: MapCallback<T>, thisArg?: {}): Array<T>;
	}
	export const from: From;
	/**
	 * Creates a new array from the function parameters.
	 *
	 * @param arguments Any number of arguments for the array
	 * @return An array from the given arguments
	 */
	export const of: (...items: any[]) => any[];
	/**
	 * Copies data internally within an array or array-like object.
	 *
	 * @param target The target array-like object
	 * @param offset The index to start copying values to; if negative, it counts backwards from length
	 * @param start The first (inclusive) index to copy; if negative, it counts backwards from length
	 * @param end The last (exclusive) index to copy; if negative, it counts backwards from length
	 * @return The target
	 */
	export const copyWithin: <T>(target: ArrayLike<T>, offset: number, start: number, end?: number) => ArrayLike<T>;
	/**
	 * Fills elements of an array-like object with the specified value.
	 *
	 * @param target The target to fill
	 * @param value The value to fill each element of the target with
	 * @param start The first index to fill
	 * @param end The (exclusive) index at which to stop filling
	 * @return The filled target
	 */
	export const fill: <T>(target: ArrayLike<T>, value: any, start?: number, end?: number) => ArrayLike<T>;
	/**
	 * Finds and returns the first instance matching the callback or undefined if one is not found.
	 *
	 * @param target An array-like object
	 * @param callback A function returning if the current value matches a criteria
	 * @param [thisArg] The execution context for the find function
	 * @return The first element matching the callback, or undefined if one does not exist
	 */
	export const find: <T>(target: ArrayLike<T>, callback: FindCallback<T>, thisArg?: {}) => T;
	/**
	 * Performs a linear search and returns the first index whose value satisfies the passed callback,
	 * or -1 if no values satisfy it.
	 *
	 * @param target An array-like object
	 * @param callback A function returning true if the current value satisfies its criteria
	 * @param [thisArg] The execution context for the find function
	 * @return The first index whose value satisfies the passed callback, or -1 if no values satisfy it
	 */
	export const findIndex: <T>(target: ArrayLike<T>, callback: FindCallback<T>, thisArg?: {}) => number;
	/**
	 * Determines whether an array includes a given value
	 *
	 * @param target the target array-like object
	 * @param searchElement the item to search for
	 * @param fromIndex the starting index to search from
	 */
	export const includes: <T>(target: ArrayLike<T>, searchElement: T, fromIndex?: number) => boolean;

}
declare module 'dojo-shim/native/Map' {
	export interface Map<K, V> {
	    clear(): void;
	    delete(key: K): boolean;
	    forEach(callbackfn: (value: V, index: K, map: Map<K, V>) => void, thisArg?: any): void;
	    get(key: K): V | undefined;
	    has(key: K): boolean;
	    set(key: K, value?: V): this;
	    size: number;
	}
	export interface MapConstructor {
	    new (): Map<any, any>;
	    new <K, V>(entries?: [K, V][]): Map<K, V>;
	    prototype: Map<any, any>;
	} const Map: MapConstructor;
	export default Map;

}
declare module 'dojo-shim/native/math' {
	/**
	 * Returns the hyperbolic arccosine of a number.
	 *
	 * @param n The number to use in calculation
	 * @return The result
	 */
	export const acosh: (n: number) => number;
	/**
	 * Returns the hyperbolic arcsine of a number.
	 *
	 * @param n The number to use in calculation
	 * @return The result
	 */
	export const asinh: (n: number) => number;
	/**
	 * Returns the hyperbolic arctangent of a number.
	 *
	 * @param n The number to use in calculation
	 * @return The result
	 */
	export const atanh: (n: number) => number;
	/**
	 * Returns the cube root of a number.
	 *
	 * @param n The number to use in calculation
	 * @return The result
	 */
	export const cbrt: (n: number) => number;
	/**
	 * Returns the number of leading zero bits in the 32-bit
	 * binary representation of a number.
	 *
	 * @param n The number to use in calculation
	 * @return The result
	 */
	export const clz32: (n: number) => number;
	/**
	 * Returns the hyperbolic cosine of a number.
	 *
	 * @param n The number to use in calculation
	 * @return The result
	 */
	export const cosh: (n: number) => number;
	/**
	 * Returns e raised to the specified power minus one.
	 *
	 * @param n The number to use in calculation
	 * @return The result
	 */
	export const expm1: (n: number) => number;
	/**
	 * Returns the nearest single-precision float representation of a number.
	 *
	 * @param n The number to use in calculation
	 * @return The result
	 */
	export const fround: (n: number) => number;
	/**
	 * Returns the square root of the sum of squares of its arguments.
	 *
	 * @return The result
	 */
	export const hypot: (...args: number[]) => number;
	/**
	 * Returns the result of the 32-bit multiplication of the two parameters.
	 *
	 * @param n The number to use in calculation
	 * @param m The number to use in calculation
	 * @return The result
	 */
	export const imul: (n: number, m: number) => number;
	/**
	 * Returns the base 2 logarithm of a number.
	 *
	 * @param n The number to use in calculation
	 * @return The result
	 */
	export const log2: (n: number) => number;
	/**
	 * Returns the base 10 logarithm of a number.
	 *
	 * @param n The number to use in calculation
	 * @return The result
	 */
	export const log10: (n: number) => number;
	/**
	 * Returns the natural logarithm of 1 + a number.
	 *
	 * @param n The number to use in calculation
	 * @return The result
	 */
	export const log1p: (n: number) => number;
	/**
	 * Returns the sign of a number, indicating whether the number is positive.
	 *
	 * @param n The number to use in calculation
	 * @return 1 if the number is positive, -1 if the number is negative, or 0 if the number is 0
	 */
	export const sign: (n: number) => number;
	/**
	 * Returns the hyperbolic sine of a number.
	 *
	 * @param n The number to use in calculation
	 * @return The result
	 */
	export const sinh: (n: number) => number;
	/**
	 * Returns the hyperbolic tangent of a number.
	 *
	 * @param n The number to use in calculation
	 * @return The result
	 */
	export const tanh: (n: number) => number;
	/**
	 * Returns the integral part of a number by removing any fractional digits.
	 *
	 * @param n The number to use in calculation
	 * @return The result
	 */
	export const trunc: (n: number) => number;

}
declare module 'dojo-shim/native/number' {
	/**
	 * The smallest interval between two representable numbers.
	 */
	export const EPSILON: any;
	/**
	 * The maximum safe integer in JavaScript
	 */
	export const MAX_SAFE_INTEGER: any;
	/**
	 * The minimum safe integer in JavaScript
	 */
	export const MIN_SAFE_INTEGER: any;
	/**
	 * Determines whether the passed value is NaN without coersion.
	 *
	 * @param value The value to test
	 * @return true if the value is NaN, false if it is not
	 */
	export const isNaN: any;
	/**
	 * Determines whether the passed value is a finite number without coersion.
	 *
	 * @param value The value to test
	 * @return true if the value is finite, false if it is not
	 */
	export const isFinite: any;
	/**
	 * Determines whether the passed value is an integer.
	 *
	 * @param value The value to test
	 * @return true if the value is an integer, false if it is not
	 */
	export const isInteger: any;
	/**
	 * Determines whether the passed value is an integer that is 'safe,' meaning:
	 *   1. it can be expressed as an IEEE-754 double precision number
	 *   2. it has a one-to-one mapping to a mathematical integer, meaning its
	 *      IEEE-754 representation cannot be the result of rounding any other
	 *      integer to fit the IEEE-754 representation
	 *
	 * @param value The value to test
	 * @return true if the value is an integer, false if it is not
	 */
	export const isSafeInteger: any;

}
declare module 'dojo-shim/native/object' {
	/**
	 * Determines whether two values are the same value.
	 *
	 * @param value1 The first value to compare
	 * @param value2 The second value to compare
	 * @return true if the values are the same; false otherwise
	 */
	export const is: (value1: any, value2: any) => boolean;
	/**
	 * Returns an array of own properties who key is a symbol
	 *
	 * @param o The object to return the properties for
	 */
	export const getOwnPropertySymbols: (o: any) => symbol[];
	/**
	 * Returns an array of own properties who key is a string
	 *
	 * @param o The object to return the properties for
	 */
	export const getOwnPropertyNames: (o: any) => string[];

}
declare module 'dojo-shim/native/Promise' {
	import { Thenable } from 'dojo-shim/interfaces';
	import { Iterable } from 'dojo-shim/native/iterator';
	/**
	 * The State enum represents the possible states of a promise.
	 */
	export const enum State {
	    Fulfilled = 0,
	    Pending = 1,
	    Rejected = 2,
	}
	/**
	 * Executor is the interface for functions used to initialize a Promise.
	 */
	export interface Executor<T> {
	    /**
	     * The executor for the promise
	     *
	     * @param resolve The resolver callback of the promise
	     * @param reject The rejector callback of the promise
	     */
	    (resolve: (value?: T | Thenable<T>) => void, reject: (reason?: any) => void): void;
	}
	/**
	 * Returns true if a given value has a `then` method.
	 * @param {any} value The value to check if is Thenable
	 * @returns {is Thenable<T>} A type guard if the value is thenable
	 */
	export function isThenable<T>(value: any): value is Thenable<T>;
	/**
	 * PlatformPromise is a very thin wrapper around either a native promise implementation or PromiseShim.
	 */
	export default class Promise<T> implements Thenable<T> {
	    /**
	     * Points to the promise constructor this platform should use.
	     */
	    static PromiseConstructor: any;
	    /**
	     * Converts an iterable object containing promises into a single promise that resolves to a new iterable object
	     * containing the fulfilled values of all the promises in the iterable, in the same order as the Promises in the
	     * iterable. Iterable values that are not promises are converted to promises using PromiseShim.resolve.
	     *
	     * @example
	     * PromiseShim.all([ PromiseShim.resolve('foo'), 'bar' ]).then(function (value) {
	     *     value[0] === 'foo'; // true
	     *     value[1] === 'bar'; // true
	     * });
	     *
	     * @example
	     * PromiseShim.all({
	     *     foo: PromiseShim.resolve('foo'),
	     *     bar: 'bar'
	     * }).then((value) => {
	     *     value.foo === 'foo'; // true
	     *     value.bar === 'bar'; // true
	     * });
	     */
	    static all<T>(iterable: Iterable<(T | Thenable<T>)> | (T | Thenable<T>)[]): Promise<T[]>;
	    /**
	     * Converts an iterable object containing promises into a single promise that resolves or rejects as soon as one of
	     * the promises in the iterable resolves or rejects, with the value of the resolved or rejected promise. Values in
	     * the iterable that are not Promises are converted to Promises with PromiseShim.resolve.
	     *
	     * @example
	     * PromiseShim.race([ PromiseShim.resolve('foo'), PromiseShim.resolve('bar') ]).then((value) => {
	     *     value === 'foo'; // true
	     * });
	     *
	     * @example
	     * PromiseShim.race({
	     *     foo: PromiseShim.resolve('foo'),
	     *     bar: PromiseShim.resolve('bar')
	     * }).then((value) => {
	     *     value === 'foo'; // true
	     * });
	     */
	    static race<T>(iterable: Iterable<(T | Thenable<T>)> | (T | Thenable<T>)[]): Promise<T>;
	    /**
	     * Creates a new promise that is rejected with the given error.
	     */
	    static reject<T>(reason: Error): Promise<any>;
	    /**
	     * Creates a new promise that is resolved with the given value. If the passed value is already a PromiseShim, it
	     * will be returned as-is.
	     */
	    static resolve(): Promise<void>;
	    static resolve<T>(value: (T | Thenable<T>)): Promise<T>;
	    /**
	     * Copies another Promise, taking on its inner state.
	     */
	    protected static copy<U>(other: Promise<U>): Promise<U>;
	    /**
	     * Creates a new Promise.
	     *
	     * @constructor
	     *
	     * @param executor
	     * The executor function is called immediately when the PromiseShim is instantiated. It is responsible for
	     * starting the asynchronous operation when it is invoked.
	     *
	     * The executor must call either the passed `resolve` function when the asynchronous operation has completed
	     * successfully, or the `reject` function when the operation fails.
	     */
	    constructor(executor: Executor<T>);
	    /**
	     * An object wrapped by this class that actually implements the Promise API.
	     */
	    promise: any;
	    /**
	     * The internal state of this promise. This may be updated directly by subclasses.
	     */
	    protected _state: State;
	    /**
	     * Adds a callback to the promise to be invoked when the asynchronous operation throws an error.
	     */
	    catch<U>(onRejected: (reason?: Error) => (U | Thenable<U>)): Promise<U>;
	    /**
	     * Allows for cleanup actions to be performed after resolution of a Promise.
	     */
	    finally(callback: () => void | Thenable<any>): Promise<T>;
	    /**
	     * The current Promise state.
	     */
	    readonly state: State;
	    /**
	     * Adds a callback to the promise to be invoked when the asynchronous operation completes successfully.
	     */
	    then<U>(onFulfilled?: ((value?: T) => (U | Thenable<U> | null | undefined)) | null | undefined, onRejected?: (reason?: Error) => void): Promise<U>;
	}

}
declare module 'dojo-shim/native/Set' {
	export interface Set<T> {
	    add(value: T): this;
	    clear(): void;
	    delete(value: T): boolean;
	    forEach(callbackfn: (value: T, index: T, set: Set<T>) => void, thisArg?: any): void;
	    has(value: T): boolean;
	    size: number;
	}
	export interface SetConstructor {
	    new (): Set<any>;
	    new <T>(values?: T[]): Set<T>;
	    prototype: Set<any>;
	} const Set: SetConstructor;
	export default Set;

}
declare module 'dojo-shim/native/string' {
	/**
	 * The minimum location of high surrogates
	 */
	export const HIGH_SURROGATE_MIN: number;
	/**
	 * The maximum location of high surrogates
	 */
	export const HIGH_SURROGATE_MAX: number;
	/**
	 * The minimum location of low surrogates
	 */
	export const LOW_SURROGATE_MIN: number;
	/**
	 * The maximum location of low surrogates
	 */
	export const LOW_SURROGATE_MAX: number;
	/**
	 * A tag function for template strings to get the template string's raw string form.
	 *
	 * @param callSite Call site object (or a template string in TypeScript, which will transpile to one)
	 * @param substitutions Values to substitute within the template string (TypeScript will generate these automatically)
	 * @return String containing the raw template string with variables substituted
	 *
	 * @example
	 * // Within TypeScript; logs 'The answer is:\\n42'
	 * let answer = 42;
	 * console.log(string.raw`The answer is:\n${answer}`);
	 *
	 * @example
	 * // The same example as above, but directly specifying a JavaScript object and substitution
	 * console.log(string.raw({ raw: [ 'The answer is:\\n', '' ] }, 42));
	 */
	export const raw: (callSite: TemplateStringsArray, ...substitutions: any[]) => string;
	/**
	 * Returns the UTF-16 encoded code point value of a given position in a string.
	 *
	 * @param text The string containing the element whose code point is to be determined
	 * @param position Position of an element within the string to retrieve the code point value from
	 * @return A non-negative integer representing the UTF-16 encoded code point value
	 */
	export const fromCodePoint: (...codePoints: number[]) => string;
	/**
	 * Returns the UTF-16 encoded code point value of a given position in a string.
	 *
	 * @param text The string containing the element whose code point is to be determined
	 * @param position Position of an element within the string to retrieve the code point value from
	 * @return A non-negative integer representing the UTF-16 encoded code point value
	 */
	export const codePointAt: (text: string, position?: number) => number;
	/**
	 * Returns a string containing the given string repeated the specified number of times.
	 *
	 * @param text The string to repeat
	 * @param count The number of times to repeat the string
	 * @return A string containing the input string repeated count times
	 */
	export const repeat: (text: string, count?: number) => string;
	/**
	 * Determines whether a string begins with the given substring (optionally starting from a given index).
	 *
	 * @param text The string to look for the search string within
	 * @param search The string to search for
	 * @param position The index to begin searching at
	 * @return Boolean indicating if the search string was found at the beginning of the given string
	 */
	export const startsWith: (text: string, search: string, position?: number) => boolean;
	/**
	 * Determines whether a string ends with the given substring.
	 *
	 * @param text The string to look for the search string within
	 * @param search The string to search for
	 * @param endPosition The index searching should stop before (defaults to text.length)
	 * @return Boolean indicating if the search string was found at the end of the given string
	 */
	export const endsWith: (text: string, search: string, endPosition?: number) => boolean;
	/**
	 * Determines whether a string includes the given substring (optionally starting from a given index).
	 *
	 * @param text The string to look for the search string within
	 * @param search The string to search for
	 * @param position The index to begin searching at
	 * @return Boolean indicating if the search string was found within the given string
	 */
	export const includes: (text: string, search: string, position?: number) => boolean;

}
declare module 'dojo-shim/native/Symbol' {
	 const SymbolShim: SymbolConstructor;
	export function isSymbol(value: any): value is symbol;
	export default SymbolShim;

}
declare module 'dojo-shim/native/WeakMap' {
	export interface WeakMap<K, V> {
	    clear(): void;
	    delete(key: K): boolean;
	    get(key: K): V;
	    has(key: K): boolean;
	    set(key: K, value?: V): this;
	}
	export interface WeakMapConstructor {
	    new (): WeakMap<any, any>;
	    new <K, V>(entries?: [K, V][]): WeakMap<K, V>;
	    prototype: WeakMap<any, any>;
	} const WeakMap: WeakMapConstructor;
	export default WeakMap;

}
declare module 'dojo-shim/native/main' {
	import * as array from 'dojo-shim/native/array';
	import * as iterator from 'dojo-shim/native/iterator';
	import Map from 'dojo-shim/native/Map';
	import * as math from 'dojo-shim/native/math';
	import * as number from 'dojo-shim/native/number';
	import * as object from 'dojo-shim/native/object';
	import Promise from 'dojo-shim/native/Promise';
	import Set from 'dojo-shim/native/Set';
	import * as string from 'dojo-shim/native/string';
	import Symbol from 'dojo-shim/native/Symbol';
	import WeakMap from 'dojo-shim/native/WeakMap';
	export { array, iterator, Map, math, number, object, Promise, Set, string, Symbol, WeakMap };

}
declare module 'dojo-shim/support/interfaces' {
	export interface Handle {
		/**
		 * Destroy/remove the reference this handle relates to
		 */
		destroy(): void;
	}

}
declare module 'dojo-shim/support/queue' {
	import { Handle } from 'dojo-shim/support/interfaces';
	export interface QueueItem {
	    isActive: boolean;
	    callback: (...args: any[]) => any;
	}
	/**
	 * Schedules a callback to the macrotask queue.
	 *
	 * @param callback the function to be queued and later executed.
	 * @returns An object with a `destroy` method that, when called, prevents the registered callback from executing.
	 */
	export const queueTask: (callback: (...args: any[]) => any) => Handle;
	/**
	 * Schedules a callback to the microtask queue.
	 *
	 * Any callbacks registered with `queueMicroTask` will be executed before the next macrotask. If no native
	 * mechanism for scheduling macrotasks is exposed, then any callbacks will be fired before any macrotask
	 * registered with `queueTask` or `queueAnimationTask`.
	 *
	 * @param callback the function to be queued and later executed.
	 * @returns An object with a `destroy` method that, when called, prevents the registered callback from executing.
	 */
	export const queueMicroTask: (callback: (...args: any[]) => any) => Handle;

}
declare module 'dojo-shim/Promise' {
	import { Thenable } from 'dojo-shim/interfaces';
	import { Iterable } from 'dojo-shim/iterator';
	import 'dojo-shim/Symbol';
	/**
	 * The State enum represents the possible states of a promise.
	 */
	export const enum State {
	    Fulfilled = 0,
	    Pending = 1,
	    Rejected = 2,
	}
	/**
	 * Executor is the interface for functions used to initialize a Promise.
	 */
	export interface Executor<T> {
	    /**
	     * The executor for the promise
	     *
	     * @param resolve The resolver callback of the promise
	     * @param reject The rejector callback of the promise
	     */
	    (resolve: (value?: T | Thenable<T>) => void, reject: (reason?: any) => void): void;
	}
	/**
	 * Returns true if a given value has a `then` method.
	 * @param {any} value The value to check if is Thenable
	 * @returns {is Thenable<T>} A type guard if the value is thenable
	 */
	export function isThenable<T>(value: any): value is Thenable<T>;
	/**
	 * PromiseShim is a partial implementation of the ES2015 Promise specification. It relies on Promise to do some safety
	 * checks such as verifying that a Promise isn't resolved with itself. This class is exported for testability, and is
	 * not intended to be used directly.
	 *
	 * @borrows Promise.all as PromiseShim.all
	 * @borrows Promise.race as PromiseShim.race
	 * @borrows Promise.reject as PromiseShim.reject
	 * @borrows Promise.resolve as PromiseShim.resolve
	 * @borrows Promise#catch as PromiseShim#catch
	 * @borrows Promise#then as PromiseShim#then
	 */
	export class PromiseShim<T> implements Thenable<T> {
	    static all<T>(iterable: Iterable<(T | Thenable<T>)> | (T | Thenable<T>)[]): PromiseShim<T[]>;
	    static race<T>(iterable: Iterable<(T | Thenable<T>)> | (T | Thenable<T>)[]): PromiseShim<T[]>;
	    static reject<T>(reason?: Error): PromiseShim<T>;
	    static resolve(): PromiseShim<void>;
	    static resolve<T>(value: (T | Thenable<T>)): PromiseShim<T>;
	    /**
	     * Creates a new PromiseShim.
	     *
	     * @constructor
	     *
	     * @param executor
	     * The executor function is called immediately when the PromiseShim is instantiated. It is responsible for
	     * starting the asynchronous operation when it is invoked.
	     *
	     * The executor must call either the passed `resolve` function when the asynchronous operation has completed
	     * successfully, or the `reject` function when the operation fails.
	     */
	    constructor(executor: Executor<T>);
	    /**
	     * The current state of this promise.
	     */
	    private state;
	    /**
	     * The resolved value for this promise.
	     *
	     * @type {T|Error}
	     */
	    private resolvedValue;
	    then: <U>(onFulfilled?: (value?: T) => (U | Thenable<U>), onRejected?: (reason?: Error) => (U | Thenable<U>)) => PromiseShim<U>;
	    [Symbol.toStringTag]: string;
	}
	/**
	 * PlatformPromise is a very thin wrapper around either a native promise implementation or PromiseShim.
	 */
	export default class Promise<T> implements Thenable<T> {
	    /**
	     * Points to the promise constructor this platform should use.
	     */
	    static PromiseConstructor: any;
	    /**
	     * Converts an iterable object containing promises into a single promise that resolves to a new iterable object
	     * containing the fulfilled values of all the promises in the iterable, in the same order as the Promises in the
	     * iterable. Iterable values that are not promises are converted to promises using PromiseShim.resolve.
	     *
	     * @example
	     * PromiseShim.all([ PromiseShim.resolve('foo'), 'bar' ]).then(function (value) {
	     *     value[0] === 'foo'; // true
	     *     value[1] === 'bar'; // true
	     * });
	     *
	     * @example
	     * PromiseShim.all({
	     *     foo: PromiseShim.resolve('foo'),
	     *     bar: 'bar'
	     * }).then((value) => {
	     *     value.foo === 'foo'; // true
	     *     value.bar === 'bar'; // true
	     * });
	     */
	    static all<T>(iterable: Iterable<(T | Thenable<T>)> | (T | Thenable<T>)[]): Promise<T[]>;
	    /**
	     * Converts an iterable object containing promises into a single promise that resolves or rejects as soon as one of
	     * the promises in the iterable resolves or rejects, with the value of the resolved or rejected promise. Values in
	     * the iterable that are not Promises are converted to Promises with PromiseShim.resolve.
	     *
	     * @example
	     * PromiseShim.race([ PromiseShim.resolve('foo'), PromiseShim.resolve('bar') ]).then((value) => {
	     *     value === 'foo'; // true
	     * });
	     *
	     * @example
	     * PromiseShim.race({
	     *     foo: PromiseShim.resolve('foo'),
	     *     bar: PromiseShim.resolve('bar')
	     * }).then((value) => {
	     *     value === 'foo'; // true
	     * });
	     */
	    static race<T>(iterable: Iterable<(T | Thenable<T>)> | (T | Thenable<T>)[]): Promise<T>;
	    /**
	     * Creates a new promise that is rejected with the given error.
	     */
	    static reject<T>(reason: Error): Promise<any>;
	    /**
	     * Creates a new promise that is resolved with the given value. If the passed value is already a PromiseShim, it
	     * will be returned as-is.
	     */
	    static resolve(): Promise<void>;
	    static resolve<T>(value: (T | Thenable<T>)): Promise<T>;
	    /**
	     * Copies another Promise, taking on its inner state.
	     */
	    protected static copy<U>(other: Promise<U>): Promise<U>;
	    /**
	     * Creates a new Promise.
	     *
	     * @constructor
	     *
	     * @param executor
	     * The executor function is called immediately when the PromiseShim is instantiated. It is responsible for
	     * starting the asynchronous operation when it is invoked.
	     *
	     * The executor must call either the passed `resolve` function when the asynchronous operation has completed
	     * successfully, or the `reject` function when the operation fails.
	     */
	    constructor(executor: Executor<T>);
	    /**
	     * An object wrapped by this class that actually implements the Promise API.
	     */
	    promise: any;
	    /**
	     * The internal state of this promise. This may be updated directly by subclasses.
	     */
	    protected _state: State;
	    /**
	     * Adds a callback to the promise to be invoked when the asynchronous operation throws an error.
	     */
	    catch<U>(onRejected: (reason?: Error) => (U | Thenable<U>)): Promise<U>;
	    /**
	     * Allows for cleanup actions to be performed after resolution of a Promise.
	     */
	    finally(callback: () => void | Thenable<any>): Promise<T>;
	    /**
	     * The current Promise state.
	     */
	    readonly state: State;
	    /**
	     * Adds a callback to the promise to be invoked when the asynchronous operation completes successfully.
	     */
	    then<U>(onFulfilled?: ((value?: T) => (U | Thenable<U> | null | undefined)) | null | undefined, onRejected?: (reason?: Error) => void): Promise<U>;
	}

}
