'use strict';
(function (args) {
    const globalObject = Function('return this')();
    const EXECUTING = 'executing';
    const ABORT_EXECUTION = {};
    //
    // loader state data
    //
    // hash: (mid | url)-->(function | string)
    //
    // A cache of resources. The resources arrive via a require.cache application, which takes a hash from either
    // mid --> function or url --> string. The function associated with mid keys causes the same code to execute as if
    // the module was script injected.
    //
    // Both kinds of key-value pairs are entered into cache via the function consumePendingCache, which may relocate
    // keys as given by any mappings *iff* the cache was received as part of a module resource request.
    let cache = {};
    let checkCompleteGuard = 0;
    // The configuration passed to the loader
    let config = {
        baseUrl: './',
        packages: [],
        paths: {},
        pkgs: {}
    };
    // The arguments sent to loader via AMD define().
    let moduleDefinitionArguments = null;
    // The list of modules that need to be evaluated.
    let executionQueue = [];
    let executedSomething = false;
    let injectUrl;
    // array of quads as described by computeMapProg; map-key is AMD map key, map-value is AMD map value
    let mapPrograms = [];
    // A hash: (mid) --> (module-object) the module namespace
    //
    // pid: the package identifier to which the module belongs (e.g., "dojo"); "" indicates the system or default
    // 	package
    // mid: the fully-resolved (i.e., mappings have been applied) module identifier without the package identifier
    // 	(e.g., "dojo/io/script")
    // url: the URL from which the module was retrieved
    // pack: the package object of the package to which the module belongs
    // executed: false => not executed; EXECUTING => in the process of tranversing deps and running factory;
    // 	true => factory has been executed
    // deps: the dependency array for this module (array of modules objects)
    // def: the factory for this module
    // result: the result of the running the factory for this module
    // injected: true => module has been injected
    // load, normalize: plugin functions applicable only for plugins
    //
    // Modules go through several phases in creation:
    //
    // 1. Requested: some other module's definition or a require application contained the requested module in
    //    its dependency array
    //
    // 2. Injected: a script element has been appended to the insert-point element demanding the resource implied by
    //    the URL
    //
    // 3. Loaded: the resource injected in [2] has been evaluated.
    //
    // 4. Defined: the resource contained a define statement that advised the loader about the module.
    //
    // 5. Evaluated: the module was defined via define and the loader has evaluated the factory and computed a result.
    let modules = {};
    // list of (from-path, to-path, regex, length) derived from paths;
    // a "program" to apply paths; see computeMapProg
    let pathMapPrograms = [];
    // hash: (mid | url)-->(function | string)
    //
    // Gives a set of cache modules pending entry into cache. When cached modules are published to the loader, they are
    // entered into pendingCacheInsert; modules are then pressed into cache upon (1) AMD define or (2) upon receiving
    // another independent set of cached modules. (1) is the usual case, and this case allows normalizing mids given
    // in the pending cache for the local configuration, possibly relocating modules.
    let pendingCacheInsert = {};
    let setGlobals;
    let uidGenerator = 0;
    // the number of modules the loader has injected but has not seen defined
    let waitingCount = 0;
    const has = (function () {
        const hasCache = Object.create(null);
        const global = globalObject;
        const document = global.document;
        const element = document && document.createElement('div');
        const has = function (name) {
            return typeof hasCache[name] === 'function' ?
                (hasCache[name] = hasCache[name](global, document, element)) : hasCache[name];
        };
        has.add = function (name, test, now, force) {
            (!(name in hasCache) || force) && (hasCache[name] = test);
            now && has(name);
        };
        return has;
    })();
    const requireModule = function (dependencies, callback) {
        return contextRequire(dependencies, callback);
    };
    const listenerQueues = {};
    const reportModuleLoadError = function (parent, module, url) {
        const parentMid = (parent ? ` (parent: ${parent.mid})` : '');
        const message = `Failed to load module ${module.mid} from ${url}${parentMid}`;
        const error = mix(new Error(message), {
            src: 'dojo/loader',
            info: {
                module,
                url,
                parentMid
            }
        });
        if (!emit('error', error)) {
            throw error;
        }
        ;
    };
    const emit = function (type, args) {
        let queue = listenerQueues[type];
        let hasListeners = queue && queue.length;
        if (hasListeners) {
            for (let listener of queue.slice(0)) {
                listener.apply(null, Array.isArray(args) ? args : [args]);
            }
        }
        return hasListeners;
    };
    const on = function (type, listener) {
        let queue = listenerQueues[type] || (listenerQueues[type] = []);
        queue.push(listener);
        return {
            remove() {
                queue.splice(queue.indexOf(listener), 1);
            }
        };
    };
    requireModule.has = has;
    requireModule.on = on;
    has.add('host-browser', typeof document !== 'undefined' && typeof location !== 'undefined');
    has.add('host-node', typeof process === 'object' && process.versions && process.versions.node);
    has.add('host-nashorn', typeof load === 'function' && typeof Packages !== 'undefined');
    has.add('debug', true);
    // IE9 will process multiple scripts at once before firing their respective onload events, so some extra work
    // needs to be done to associate the content of the define call with the correct node. This is known to be fixed
    // in IE10 and the bad behaviour cannot be inferred through feature detection, so simply target this one user-agent
    has.add('loader-ie9-compat', has('host-browser') && navigator.userAgent.indexOf('MSIE 9.0') > -1);
    has.add('loader-configurable', true);
    if (has('loader-configurable')) {
        /**
         * Configures the loader.
         *
         * @param {{ ?baseUrl: string, ?map: Object, ?packages: Array.<({ name, ?location, ?main }|string)> }} config
         * The configuration data.
         */
        requireModule.config = function (configuration) {
            // Make sure baseUrl ends in a slash
            if (configuration.baseUrl) {
                configuration.baseUrl = configuration.baseUrl.replace(/\/*$/, '/');
            }
            const mergeProps = {
                paths: true,
                bundles: true,
                config: true,
                map: true
            };
            // Copy configuration over to config object
            for (let key in configuration) {
                const value = configuration[key];
                if (mergeProps[key]) {
                    if (!config[key]) {
                        config[key] = {};
                    }
                    mix(config[key], value, true);
                }
                else {
                    config[key] = value;
                }
            }
            // TODO: Expose all properties on req as getter/setters? Plugin modules like dojo/node being able to
            // retrieve baseUrl is important. baseUrl is defined as a getter currently.
            forEach(configuration.packages, function (packageDescriptor) {
                // Allow shorthand package definition, where name and location are the same
                if (typeof packageDescriptor === 'string') {
                    packageDescriptor = { name: packageDescriptor, location: packageDescriptor };
                }
                if (packageDescriptor.location != null) {
                    packageDescriptor.location = packageDescriptor.location.replace(/\/*$/, '/');
                }
                config.pkgs[packageDescriptor.name] = packageDescriptor;
            });
            function computeMapProgram(map) {
                // This method takes a map as represented by a JavaScript object and initializes an array of
                // arrays of (map-key, map-value, regex-for-map-key, length-of-map-key), sorted decreasing by length-
                // of-map-key. The regex looks for the map-key followed by either "/" or end-of-string at the beginning
                // of a the search source.
                //
                // Maps look like this:
                //
                // map: { C: { D: E } }
                //    A	B
                //
                // The computed mapping is a 4-array deep tree, where the outermost array corresponds to the source
                // mapping object A, the 2nd level arrays each correspond to one of the source mappings C -> B, the 3rd
                // level arrays correspond to each destination mapping object B, and the innermost arrays each
                // correspond to one of the destination mappings D -> E.
                //
                // So, the overall structure looks like this:
                //
                // mapPrograms = [ source mapping array, source mapping array, ... ]
                // source mapping array = [
                //     source module id,
                //     [ destination mapping array, destination mapping array, ... ],
                //     RegExp that matches on source module id,
                //     source module id length
                // ]
                // destination mapping array = [
                //     original module id,
                //     destination module id,
                //     RegExp that matches on original module id,
                //     original module id length
                // ]
                const result = [];
                for (let moduleId in map) {
                    const value = map[moduleId];
                    const isValueAMapReplacement = typeof value === 'object';
                    const item = {
                        0: moduleId,
                        1: isValueAMapReplacement ? computeMapProgram(value) : value,
                        2: new RegExp('^' + moduleId.replace(/[-\[\]{}()*+?.,\\\^$|#\s]/g, '\\$&') + '(?:\/|$)'),
                        3: moduleId.length
                    };
                    result.push(item);
                    if (isValueAMapReplacement && moduleId === '*') {
                        result.star = item[1];
                    }
                }
                result.sort(function (left, right) {
                    return right[3] - left[3];
                });
                return result;
            }
            // FIXME this is a down-cast.
            // computeMapProgram => MapItem[] => mapPrograms: MapSource[]
            // MapSource[1] => MapReplacement[] is more specific than MapItems[1] => any
            mapPrograms = computeMapProgram(config.map);
            // Note that old paths will get destroyed if reconfigured
            configuration.paths && (pathMapPrograms = computeMapProgram(configuration.paths));
        };
    }
    function forEach(array, callback) {
        array && array.forEach(callback);
    }
    function mix(target, source, deep) {
        if (source) {
            for (let key in source) {
                let sourceValue = source[key];
                if (deep && typeof sourceValue === 'object' &&
                    !Array.isArray(sourceValue) && !(sourceValue instanceof RegExp)) {
                    if (!target[key]) {
                        target[key] = {};
                    }
                    mix(target[key], sourceValue, true);
                }
                else {
                    target[key] = sourceValue;
                }
            }
        }
        return target;
    }
    function consumePendingCacheInsert(referenceModule) {
        let item;
        for (let key in pendingCacheInsert) {
            item = pendingCacheInsert[key];
            cache[typeof item === 'string' ? toUrl(key, referenceModule) : getModuleInformation(key, referenceModule).mid] = item;
        }
        pendingCacheInsert = {};
    }
    function noop() { }
    ;
    let loadNodeModule = noop;
    function contextRequire(dependencies, callback, referenceModule) {
        let module;
        if (typeof dependencies === 'string') {
            module = getModule(dependencies, referenceModule);
            if (module.executed !== true && module.executed !== EXECUTING) {
                if (has('host-node') && !module.plugin) {
                    let result = loadNodeModule(module.mid, referenceModule);
                    if (result) {
                        initializeModule(module, [], null);
                        module.result = result;
                        module.cjs.setExports(result);
                        module.executed = true;
                        module.injected = true;
                    }
                    else {
                        throw new Error('Attempt to require unloaded module ' + module.mid);
                    }
                }
                else if (module.plugin) {
                    injectModule(module, null);
                }
            }
            // Assign the result of the module to `module`
            // otherwise require('moduleId') returns the internal
            // module representation
            module = module.result;
        }
        else if (Array.isArray(dependencies)) {
            // signature is (requestList [,callback])
            // construct a synthetic module to control execution of the requestList, and, optionally, callback
            module = getModuleInformation('*' + (++uidGenerator));
            mix(module, {
                deps: resolveDependencies(dependencies, module, referenceModule),
                def: callback || {},
                gc: true // garbage collect
            });
            guardCheckComplete(function () {
                forEach(module.deps, injectModule.bind(null, module));
            });
            executionQueue.push(module);
            checkComplete();
        }
        return module;
    }
    function createRequire(module) {
        let result = (!module && requireModule) || module.require;
        if (!result) {
            module.require = result = function (dependencies, callback) {
                return contextRequire(dependencies, callback, module);
            };
            mix(mix(result, requireModule), {
                toUrl: function (name) {
                    return toUrl(name, module);
                },
                toAbsMid: function (mid) {
                    return toAbsMid(mid, module);
                }
            });
        }
        return result;
    }
    function runMapProgram(targetModuleId, map) {
        // search for targetModuleId in map; return the map item if found; falsy otherwise
        if (map) {
            for (let i = 0, j = map.length; i < j; ++i) {
                if (map[i][2].test(targetModuleId)) {
                    return map[i];
                }
            }
        }
        return null;
    }
    function compactPath(path) {
        const pathSegments = path.replace(/\\/g, '/').split('/');
        let absolutePathSegments = [];
        let segment;
        let lastSegment;
        while (pathSegments.length) {
            segment = pathSegments.shift();
            if (segment === '..' && absolutePathSegments.length && lastSegment !== '..') {
                absolutePathSegments.pop();
                lastSegment = absolutePathSegments[absolutePathSegments.length - 1];
            }
            else if (segment !== '.') {
                absolutePathSegments.push((lastSegment = segment));
            } // else ignore "."
        }
        return absolutePathSegments.join('/');
    }
    function updateModuleIdFromMap(moduleId, referenceModule) {
        // relative module ids are relative to the referenceModule; get rid of any dots
        moduleId = compactPath(/^\./.test(moduleId) && referenceModule ?
            (referenceModule.mid + '/../' + moduleId) : moduleId);
        // at this point, moduleId is an absolute moduleId
        // if there is a reference module, then use its module map, if one exists; otherwise, use the global map.
        // see computeMapProg for more information on the structure of the map arrays
        let moduleMap = referenceModule && runMapProgram(referenceModule.mid, mapPrograms);
        moduleMap = moduleMap ? moduleMap[1] : mapPrograms.star;
        let mapItem;
        if ((mapItem = runMapProgram(moduleId, moduleMap))) {
            moduleId = mapItem[1] + moduleId.slice(mapItem[3]);
        }
        return moduleId;
    }
    function getPluginInformation(moduleId, match, referenceModule) {
        const plugin = getModule(match[1], referenceModule);
        const isPluginLoaded = Boolean(plugin.load);
        const contextRequire = createRequire(referenceModule);
        let pluginResourceId;
        if (isPluginLoaded) {
            pluginResourceId = resolvePluginResourceId(plugin, match[2], contextRequire);
            moduleId = (plugin.mid + '!' + pluginResourceId);
        }
        else {
            // if not loaded, need to mark in a way that it will get properly resolved later
            pluginResourceId = match[2];
            moduleId = plugin.mid + '!' + (++uidGenerator) + '!*';
        }
        return {
            plugin: plugin,
            mid: moduleId,
            req: contextRequire,
            prid: pluginResourceId,
            fix: !isPluginLoaded
        };
    }
    function getModuleInformation(moduleId, referenceModule) {
        let match = moduleId.match(/^([^\/]+)(\/(.+))?$/);
        let packageId = match ? match[1] : '';
        let pack = config.pkgs[packageId];
        let moduleIdInPackage;
        if (pack) {
            moduleId = packageId + '/' + (moduleIdInPackage = (match[3] || pack.main || 'main'));
        }
        else {
            packageId = '';
        }
        let module = modules[moduleId];
        if (!(module)) {
            let mapItem = runMapProgram(moduleId, pathMapPrograms);
            let url = mapItem ? mapItem[1] + moduleId.slice(mapItem[3]) : (packageId ? pack.location + moduleIdInPackage : moduleId);
            module = {
                pid: packageId,
                mid: moduleId,
                pack: pack,
                url: compactPath(
                // absolute urls should not be prefixed with baseUrl
                (/^(?:\/|\w+:)/.test(url) ? '' : config.baseUrl) +
                    url +
                    // urls with a javascript extension should not have another one added
                    (/\.js(?:\?[^?]*)?$/.test(url) ? '' : '.js'))
            };
        }
        return module;
    }
    function resolvePluginResourceId(plugin, pluginResourceId, contextRequire) {
        return plugin.normalize ? plugin.normalize(pluginResourceId, contextRequire.toAbsMid) :
            contextRequire.toAbsMid(pluginResourceId);
    }
    function getModule(moduleId, referenceModule) {
        // compute and construct (if necessary) the module implied by the moduleId with respect to referenceModule
        let module;
        const pluginRegEx = /^(.+?)\!(.*)$/;
        // Foreseable situations (where ?-> is a map lookup function)
        // module
        // plugin!arg
        // module ?-> mappedModule
        // module ?-> mappedPlugin!arg
        // plugin!arg ?-> mappedPlugin + ! + arg
        // Do inital check on the passed in moduleId
        const passedModuleMatch = moduleId.match(pluginRegEx);
        if (passedModuleMatch) {
            // Passed in moduleId is a plugin, so check the map using only the plugin name
            // then reconstruct using the pluginArgs
            let pluginId = updateModuleIdFromMap(passedModuleMatch[1], referenceModule);
            moduleId = `${pluginId}!${passedModuleMatch[2]}`;
        }
        else {
            // Not a module, so check the map using the full moduleId passed
            moduleId = updateModuleIdFromMap(moduleId, referenceModule);
        }
        // Do final check on the mapped module / plugin Id to see what we're dealing with
        const mappedModuleMatch = moduleId.match(pluginRegEx);
        if (mappedModuleMatch) {
            module = getPluginInformation(moduleId, mappedModuleMatch, referenceModule);
        }
        else {
            module = getModuleInformation(moduleId, referenceModule);
        }
        return modules[module.mid] || (modules[module.mid] = module);
    }
    function toAbsMid(moduleId, referenceModule) {
        moduleId = updateModuleIdFromMap(moduleId, referenceModule);
        return getModuleInformation(moduleId, referenceModule).mid;
    }
    function toUrl(name, referenceModule) {
        let moduleId = name + '/x';
        moduleId = updateModuleIdFromMap(moduleId, referenceModule);
        const moduleInfo = getModuleInformation(moduleId, referenceModule);
        const url = moduleInfo.url;
        // "/x.js" since getModuleInfo automatically appends ".js" and we appended "/x" to make name look like a
        // module id
        return url.slice(0, url.length - 5);
    }
    function makeCommonJs(mid) {
        return (modules[mid] = {
            mid: mid,
            injected: true,
            executed: true
        });
    }
    const commonJsRequireModule = makeCommonJs('require');
    const commonJsExportsModule = makeCommonJs('exports');
    const commonJsModuleModule = makeCommonJs('module');
    let circularTrace;
    has.add('loader-debug-circular-dependencies', true);
    if (has('loader-debug-circular-dependencies')) {
        circularTrace = [];
    }
    function executeModule(module) {
        // run the dependency array, then run the factory for module
        if (module.executed === EXECUTING) {
            // for circular dependencies, assume the first module encountered was executed OK
            // modules that circularly depend on a module that has not run its factory will get
            // the premade cjs.exports===module.result. They can take a reference to this object and/or
            // add properties to it. When the module finally runs its factory, the factory can
            // read/write/replace this object. Notice that so long as the object isn't replaced, any
            // reference taken earlier while walking the dependencies list is still valid.
            if (has('loader-debug-circular-dependencies') &&
                module.deps.indexOf(commonJsExportsModule) === -1 &&
                typeof console !== 'undefined') {
                console.warn('Circular dependency: ' + circularTrace.concat(module.mid).join(' -> '));
            }
            return module.result;
        }
        if (!module.executed) {
            // TODO: This seems like an incorrect condition inference. Originally it was simply !module.def
            // which caused modules with falsy defined values to never execute.
            if (!module.def && !module.deps) {
                return ABORT_EXECUTION;
            }
            has('loader-debug-circular-dependencies') && circularTrace.push(module.mid);
            const dependencies = module.deps;
            let result;
            module.executed = EXECUTING;
            let executedDependencies = dependencies.map(function (dependency) {
                if (result !== ABORT_EXECUTION) {
                    // check for keyword dependencies: DojoLoader.require, exports, module; then execute module dependency
                    result = ((dependency === commonJsRequireModule) ? createRequire(module) :
                        ((dependency === commonJsExportsModule) ? module.cjs.exports :
                            ((dependency === commonJsModuleModule) ? module.cjs :
                                executeModule(dependency))));
                }
                return result;
            });
            if (result === ABORT_EXECUTION) {
                module.executed = false;
                has('loader-debug-circular-dependencies') && circularTrace.pop();
                return ABORT_EXECUTION;
            }
            const factory = module.def;
            result = typeof factory === 'function' ? factory.apply(null, executedDependencies) : factory;
            // TODO: But of course, module.cjs always exists.
            // Assign the new module.result to result so plugins can use exports
            // to define their interface; the plugin checks below use result
            result = module.result = result === undefined && module.cjs ? module.cjs.exports : result;
            module.executed = true;
            executedSomething = true;
            // delete references to synthetic modules
            if (module.gc) {
                modules[module.mid] = undefined;
            }
            // if result defines load, just assume it's a plugin; harmless if the assumption is wrong
            result && result.load && ['normalize', 'load'].forEach(function (key) {
                module[key] = result[key];
            });
            // for plugins, resolve the loadQ
            forEach(module.loadQ, function (pseudoPluginResource) {
                // manufacture and insert the real module in modules
                const pluginResourceId = resolvePluginResourceId(module, pseudoPluginResource.prid, pseudoPluginResource.req);
                const moduleId = (module.mid + '!' + pluginResourceId);
                const pluginResource = mix(mix({}, pseudoPluginResource), { mid: moduleId, prid: pluginResourceId });
                if (!modules[moduleId]) {
                    // create a new (the real) plugin resource and inject it normally now that the plugin is on board
                    injectPlugin((modules[moduleId] = pluginResource));
                } // else this was a duplicate request for the same (plugin, rid)
                // pluginResource is really just a placeholder with the wrong moduleId (because we couldn't calculate it
                // until the plugin was on board) fix() replaces the pseudo module in a resolved dependencies array with the
                // real module lastly, mark the pseudo module as arrived and delete it from modules
                pseudoPluginResource.fix(modules[moduleId]);
                --waitingCount;
                modules[pseudoPluginResource.mid] = undefined;
            });
            module.loadQ = undefined;
            has('loader-debug-circular-dependencies') && circularTrace.pop();
        }
        // at this point the module is guaranteed fully executed
        return module.result;
    }
    // TODO: Figure out what proc actually is
    function guardCheckComplete(callback) {
        ++checkCompleteGuard;
        callback();
        --checkCompleteGuard;
    }
    function checkComplete() {
        // keep going through the executionQueue as long as at least one factory is executed
        // plugins, recursion, cached modules all make for many execution path possibilities
        !checkCompleteGuard && guardCheckComplete(function () {
            for (let module, i = 0; i < executionQueue.length;) {
                module = executionQueue[i];
                if (module.executed === true) {
                    executionQueue.splice(i, 1);
                }
                else {
                    executedSomething = false;
                    executeModule(module);
                    if (executedSomething) {
                        // something was executed; this indicates the executionQueue was modified, maybe a
                        // lot (for example a later module causes an earlier module to execute)
                        i = 0;
                    }
                    else {
                        // nothing happened; check the next module in the exec queue
                        i++;
                    }
                }
            }
        });
    }
    function injectPlugin(module) {
        // injects the plugin module given by module; may have to inject the plugin itself
        const plugin = module.plugin;
        const onLoad = function (def) {
            module.result = def;
            --waitingCount;
            module.executed = true;
            checkComplete();
        };
        if (plugin.load) {
            plugin.load(module.prid, module.req, onLoad, config);
        }
        else if (plugin.loadQ) {
            plugin.loadQ.push(module);
        }
        else {
            // the unshift instead of push is important: we don't want plugins to execute as
            // dependencies of some other module because this may cause circles when the plugin
            // loadQ is run; also, generally, we want plugins to run early since they may load
            // several other modules and therefore can potentially unblock many modules
            plugin.loadQ = [module];
            executionQueue.unshift(plugin);
            injectModule(module, plugin);
        }
    }
    function injectModule(parent, module) {
        // TODO: This is for debugging, we should bracket it
        if (!module) {
            module = parent;
            parent = null;
        }
        if (module.plugin) {
            injectPlugin(module);
        }
        else if (!module.injected) {
            let cached;
            const onLoadCallback = function (node) {
                // DojoLoader.moduleDefinitionArguments is an array of [dependencies, factory]
                consumePendingCacheInsert(module);
                if (has('loader-ie9-compat') && node) {
                    moduleDefinitionArguments = node.defArgs;
                }
                // non-amd module
                if (!moduleDefinitionArguments) {
                    moduleDefinitionArguments = [[], undefined];
                }
                defineModule(module, moduleDefinitionArguments[0], moduleDefinitionArguments[1]);
                moduleDefinitionArguments = null;
                guardCheckComplete(function () {
                    forEach(module.deps, injectModule.bind(null, module));
                });
                checkComplete();
            };
            ++waitingCount;
            module.injected = true;
            if ((cached = cache[module.mid])) {
                try {
                    cached();
                    onLoadCallback();
                    return;
                }
                catch (error) {
                }
            }
            injectUrl(module.url, onLoadCallback, module, parent);
        }
    }
    function resolveDependencies(dependencies, module, referenceModule) {
        // resolve dependencies with respect to this module
        return dependencies.map(function (dependency, i) {
            const result = getModule(dependency, referenceModule);
            if (result.fix) {
                result.fix = function (m) {
                    module.deps[i] = m;
                };
            }
            return result;
        });
    }
    function defineModule(module, dependencies, factory) {
        --waitingCount;
        return initializeModule(module, dependencies, factory);
    }
    function initializeModule(module, dependencies, factory) {
        return mix(module, {
            def: factory,
            deps: resolveDependencies(dependencies, module, module),
            cjs: {
                id: module.mid,
                uri: module.url,
                exports: (module.result = {}),
                setExports: function (exports) {
                    module.cjs.exports = exports;
                }
            }
        });
    }
    has.add('function-bind', Boolean(Function.prototype.bind));
    if (!has('function-bind')) {
        injectModule.bind = function (thisArg) {
            const slice = Array.prototype.slice;
            const args = slice.call(arguments, 1);
            return function () {
                return injectModule.apply(thisArg, args.concat(slice.call(arguments, 0)));
            };
        };
    }
    let globalObjectGlobals = function (require, define) {
        globalObject.require = require;
        globalObject.define = define;
    };
    if (has('host-node')) {
        loadNodeModule = (moduleId, parent) => {
            let module = require('module');
            let result;
            if (module._findPath && module._nodeModulePaths) {
                let localModulePath = module._findPath(moduleId, module._nodeModulePaths(toUrl('.', parent)));
                if (localModulePath !== false) {
                    moduleId = localModulePath;
                }
            }
            // Some modules attempt to detect an AMD loader by looking for global AMD `define`. This causes issues
            // when other CommonJS modules attempt to load them via the standard Node.js `require`, so hide it
            // during the load
            globalObject.define = undefined;
            try {
                result = requireModule.nodeRequire(moduleId);
            }
            catch (error) {
                // If the Node.js 'require' function cannot locate a module it will throw "Error: Cannot find module"
                // Leave it to the caller of this function to handle a non-existent module
                // (and throw an error if desired)
                result = undefined;
            }
            finally {
                globalObject.define = define;
            }
            return result;
        };
        const vm = require('vm');
        const fs = require('fs');
        // retain the ability to get node's require
        requireModule.nodeRequire = require;
        injectUrl = function (url, callback, module, parent) {
            fs.readFile(url, 'utf8', function (error, data) {
                function loadCallback() {
                    let result = loadNodeModule(module.mid, parent);
                    if (!result) {
                        reportModuleLoadError(parent, module, url);
                    }
                    return result;
                }
                if (error) {
                    moduleDefinitionArguments = [[], loadCallback];
                }
                else {
                    // global `module` variable needs to be shadowed for UMD modules that are loaded in an Electron
                    // webview; in Node.js the `module` variable does not exist when using `vm.runInThisContext`,
                    // but in Electron it exists in the webview when Node.js integration is enabled which causes loaded
                    // modules to register with Node.js and break the loader
                    let oldModule = globalObject.module;
                    globalObject.module = undefined;
                    try {
                        /**
                         * Using an `object` as a second argument causes Instabul
                         * issues and then thinks the file should not be instrumented
                         *
                         * See: dojo/loader#57
                         */
                        vm.runInThisContext(data, url);
                    }
                    finally {
                        globalObject.module = oldModule;
                    }
                }
                callback();
            });
        };
        setGlobals = function (require, define) {
            module.exports = globalObject.require = require;
            globalObject.define = define;
        };
    }
    else if (has('host-browser')) {
        injectUrl = function (url, callback, module, parent) {
            // insert a script element to the insert-point element with src=url;
            // apply callback upon detecting the script has loaded.
            const node = document.createElement('script');
            const handler = function (event) {
                document.head.removeChild(node);
                if (event.type === 'load') {
                    has('loader-ie9-compat') ? callback(node) : callback();
                }
                else {
                    reportModuleLoadError(parent, module, url);
                }
            };
            node.addEventListener('load', handler, false);
            node.addEventListener('error', handler, false);
            node.crossOrigin = 'anonymous';
            node.charset = 'utf-8';
            node.src = url;
            document.head.appendChild(node);
        };
        setGlobals = globalObjectGlobals;
    }
    else if (has('host-nashorn')) {
        injectUrl = function (url, callback, module, parent) {
            load(url);
            callback();
        };
        setGlobals = globalObjectGlobals;
    }
    else {
        throw new Error('Unsupported platform');
    }
    has.add('loader-debug-internals', true);
    if (has('loader-debug-internals')) {
        requireModule.inspect = function (name) {
            /* tslint:disable:no-eval */
            // TODO: Should this use console.log so people do not get any bright ideas about using this in apps?
            return eval(name);
            /* tslint:enable:no-eval */
        };
    }
    has.add('loader-undef', true);
    if (has('loader-undef')) {
        requireModule.undef = function (id) {
            if (modules[id]) {
                modules[id] = undefined;
            }
        };
    }
    mix(requireModule, {
        toAbsMid: toAbsMid,
        toUrl: toUrl,
        cache: function (cache) {
            consumePendingCacheInsert();
            pendingCacheInsert = cache;
        }
    });
    Object.defineProperty(requireModule, 'baseUrl', {
        get: function () {
            return config.baseUrl;
        },
        enumerable: true
    });
    has.add('loader-cjs-wrapping', true);
    let comments;
    let requireCall;
    if (has('loader-cjs-wrapping')) {
        comments = /\/\*[\s\S]*?\*\/|\/\/.*$/mg;
        requireCall = /require\s*\(\s*(["'])(.*?[^\\])\1\s*\)/g;
    }
    has.add('loader-explicit-mid', true);
    /**
     * @param deps //(array of commonjs.moduleId, optional)
     * @param factory //(any)
     */
    let define = mix(function (dependencies, factory) {
        let originalFactory;
        if (has('loader-explicit-mid') && arguments.length > 1 && typeof dependencies === 'string') {
            let id = dependencies;
            if (arguments.length === 3) {
                dependencies = factory;
                factory = arguments[2];
            }
            else {
                dependencies = [];
            }
            // Some modules in the wild have an explicit module ID that is null; ignore the module ID in this case and
            // register normally using the request module ID
            if (id != null) {
                let module = getModule(id);
                if (factory) {
                    originalFactory = factory;
                    factory = function () {
                        module.executed = true;
                        return (module.result = originalFactory.apply ?
                            originalFactory.apply(null, arguments) : originalFactory);
                    };
                }
                module.injected = true;
                defineModule(module, dependencies, factory);
                guardCheckComplete(function () {
                    forEach(module.deps, injectModule.bind(null, module));
                });
            }
        }
        if (arguments.length === 1) {
            if (has('loader-cjs-wrapping') && typeof dependencies === 'function') {
                originalFactory = dependencies;
                dependencies = ['require', 'exports', 'module'];
                // Scan factory for require() calls and add them to the
                // list of dependencies
                originalFactory.toString()
                    .replace(comments, '')
                    .replace(requireCall, function () {
                    dependencies.push(/* mid */ arguments[2]);
                    return arguments[0];
                });
                factory = function (require, exports, module) {
                    const originalModuleId = module.id;
                    let result = originalFactory.apply(null, arguments);
                    if (originalModuleId !== module.id) {
                        const newModule = getModule(module.id);
                        defineModule(newModule, dependencies, null);
                        newModule.injected = true;
                        newModule.executed = true;
                        newModule.result = module.exports = result || module.exports;
                    }
                    return result;
                };
            }
            else if (!Array.isArray(dependencies)) {
                const value = dependencies;
                dependencies = [];
                factory = function () {
                    return value;
                };
            }
        }
        if (has('loader-ie9-compat')) {
            for (let i = document.scripts.length - 1, script; script = document.scripts[i]; --i) {
                if (script.readyState === 'interactive') {
                    script.defArgs = [dependencies, factory];
                    break;
                }
            }
        }
        else {
            moduleDefinitionArguments = [dependencies, factory];
        }
    }, {
        amd: { vendor: 'dojotoolkit.org' }
    });
    setGlobals(requireModule, define);
    if (has('host-nashorn') && args[0]) {
        load(args[0]);
    }
})((typeof Packages !== 'undefined' ? Array.prototype.slice.call(arguments, 0) : []));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9hZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2xvYWRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxZQUFZLENBQUM7QUFDYixDQUFDLFVBQVUsSUFBZTtJQUN6QixNQUFNLFlBQVksR0FBUSxRQUFRLENBQUMsYUFBYSxDQUFDLEVBQUUsQ0FBQztJQUNwRCxNQUFNLFNBQVMsR0FBRyxXQUFXLENBQUM7SUFDOUIsTUFBTSxlQUFlLEdBQVcsRUFBRSxDQUFDO0lBQ25DLEVBQUU7SUFDRixvQkFBb0I7SUFDcEIsRUFBRTtJQUVGLDBDQUEwQztJQUMxQyxFQUFFO0lBQ0YsNkdBQTZHO0lBQzdHLGtIQUFrSDtJQUNsSCxrQ0FBa0M7SUFDbEMsRUFBRTtJQUNGLGdIQUFnSDtJQUNoSCxtR0FBbUc7SUFDbkcsSUFBSSxLQUFLLEdBQXlCLEVBQUUsQ0FBQztJQUVyQyxJQUFJLGtCQUFrQixHQUFHLENBQUMsQ0FBQztJQUUzQix5Q0FBeUM7SUFDekMsSUFBSSxNQUFNLEdBQXNCO1FBQy9CLE9BQU8sRUFBRSxJQUFJO1FBQ2IsUUFBUSxFQUFFLEVBQUU7UUFDWixLQUFLLEVBQUUsRUFBRTtRQUNULElBQUksRUFBRSxFQUFFO0tBQ1IsQ0FBQztJQUVGLGlEQUFpRDtJQUNqRCxJQUFJLHlCQUF5QixHQUF5QyxJQUFJLENBQUM7SUFFM0UsaURBQWlEO0lBQ2pELElBQUksY0FBYyxHQUF3QixFQUFFLENBQUM7SUFFN0MsSUFBSSxpQkFBaUIsR0FBRyxLQUFLLENBQUM7SUFFOUIsSUFBSSxTQUFxSSxDQUFDO0lBRTFJLG9HQUFvRztJQUNwRyxJQUFJLFdBQVcsR0FBdUIsRUFBRSxDQUFDO0lBRXpDLHlEQUF5RDtJQUN6RCxFQUFFO0lBQ0YsNkdBQTZHO0lBQzdHLFdBQVc7SUFDWCw4R0FBOEc7SUFDOUcsNEJBQTRCO0lBQzVCLG1EQUFtRDtJQUNuRCxzRUFBc0U7SUFDdEUsd0dBQXdHO0lBQ3hHLHFDQUFxQztJQUNyQyx3RUFB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LENBQUMsR0FBRyxDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzlCLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLFFBQVEsQ0FBQyxPQUFPLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxNQUF5QixFQUNsRSxNQUFNLEdBQXVCLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQ2hELEVBQUUsQ0FBQyxFQUFFLENBQUM7Z0JBQ04sRUFBRSxDQUFDLENBQVEsTUFBTyxDQUFDLFVBQVUsS0FBSyxhQUFhLENBQUMsQ0FBQyxDQUFDO29CQUMxQyxNQUFPLENBQUMsT0FBTyxHQUFHLENBQUUsWUFBWSxFQUFFLE9BQU8sQ0FBRSxDQUFDO29CQUNuRCxLQUFLLENBQUM7Z0JBQ1AsQ0FBQztZQUNGLENBQUM7UUFDRixDQUFDO1FBQ0QsSUFBSSxDQUFDLENBQUM7WUFDTCx5QkFBeUIsR0FBRyxDQUFFLFlBQVksRUFBRSxPQUFPLENBQUUsQ0FBQztRQUN2RCxDQUFDO0lBQ0YsQ0FBQyxFQUFFO1FBQ0YsR0FBRyxFQUFFLEVBQUUsTUFBTSxFQUFFLGlCQUFpQixFQUFFO0tBQ2xDLENBQUMsQ0FBQztJQUVILFVBQVUsQ0FBQyxhQUFhLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFDbEMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDcEMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2YsQ0FBQztBQUNGLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxRQUFRLEtBQUssV0FBVyxHQUFHLEtBQUssQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbihmdW5jdGlvbiAoYXJncz86IHN0cmluZ1tdKTogdm9pZCB7XG5cdGNvbnN0IGdsb2JhbE9iamVjdDogYW55ID0gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblx0Y29uc3QgRVhFQ1VUSU5HID0gJ2V4ZWN1dGluZyc7XG5cdGNvbnN0IEFCT1JUX0VYRUNVVElPTjogT2JqZWN0ID0ge307XG5cdC8vXG5cdC8vIGxvYWRlciBzdGF0ZSBkYXRhXG5cdC8vXG5cblx0Ly8gaGFzaDogKG1pZCB8IHVybCktLT4oZnVuY3Rpb24gfCBzdHJpbmcpXG5cdC8vXG5cdC8vIEEgY2FjaGUgb2YgcmVzb3VyY2VzLiBUaGUgcmVzb3VyY2VzIGFycml2ZSB2aWEgYSByZXF1aXJlLmNhY2hlIGFwcGxpY2F0aW9uLCB3aGljaCB0YWtlcyBhIGhhc2ggZnJvbSBlaXRoZXJcblx0Ly8gbWlkIC0tPiBmdW5jdGlvbiBvciB1cmwgLS0+IHN0cmluZy4gVGhlIGZ1bmN0aW9uIGFzc29jaWF0ZWQgd2l0aCBtaWQga2V5cyBjYXVzZXMgdGhlIHNhbWUgY29kZSB0byBleGVjdXRlIGFzIGlmXG5cdC8vIHRoZSBtb2R1bGUgd2FzIHNjcmlwdCBpbmplY3RlZC5cblx0Ly9cblx0Ly8gQm90aCBraW5kcyBvZiBrZXktdmFsdWUgcGFpcnMgYXJlIGVudGVyZWQgaW50byBjYWNoZSB2aWEgdGhlIGZ1bmN0aW9uIGNvbnN1bWVQZW5kaW5nQ2FjaGUsIHdoaWNoIG1heSByZWxvY2F0ZVxuXHQvLyBrZXlzIGFzIGdpdmVuIGJ5IGFueSBtYXBwaW5ncyAqaWZmKiB0aGUgY2FjaGUgd2FzIHJlY2VpdmVkIGFzIHBhcnQgb2YgYSBtb2R1bGUgcmVzb3VyY2UgcmVxdWVzdC5cblx0bGV0IGNhY2hlOiBEb2pvTG9hZGVyLk9iamVjdE1hcCA9IHt9O1xuXG5cdGxldCBjaGVja0NvbXBsZXRlR3VhcmQgPSAwO1xuXG5cdC8vIFRoZSBjb25maWd1cmF0aW9uIHBhc3NlZCB0byB0aGUgbG9hZGVyXG5cdGxldCBjb25maWc6IERvam9Mb2FkZXIuQ29uZmlnID0ge1xuXHRcdGJhc2VVcmw6ICcuLycsXG5cdFx0cGFja2FnZXM6IFtdLFxuXHRcdHBhdGhzOiB7fSxcblx0XHRwa2dzOiB7fVxuXHR9O1xuXG5cdC8vIFRoZSBhcmd1bWVudHMgc2VudCB0byBsb2FkZXIgdmlhIEFNRCBkZWZpbmUoKS5cblx0bGV0IG1vZHVsZURlZmluaXRpb25Bcmd1bWVudHM6IERvam9Mb2FkZXIuTW9kdWxlRGVmaW5pdGlvbkFyZ3VtZW50cyA9IG51bGw7XG5cblx0Ly8gVGhlIGxpc3Qgb2YgbW9kdWxlcyB0aGF0IG5lZWQgdG8gYmUgZXZhbHVhdGVkLlxuXHRsZXQgZXhlY3V0aW9uUXVldWU6IERvam9Mb2FkZXIuTW9kdWxlW10gPSBbXTtcblxuXHRsZXQgZXhlY3V0ZWRTb21ldGhpbmcgPSBmYWxzZTtcblxuXHRsZXQgaW5qZWN0VXJsOiAodXJsOiBzdHJpbmcsIGNhbGxiYWNrOiAobm9kZT86IEhUTUxTY3JpcHRFbGVtZW50KSA9PiB2b2lkLCBtb2R1bGU6IERvam9Mb2FkZXIuTW9kdWxlLCBwYXJlbnQ/OiBEb2pvTG9hZGVyLk1vZHVsZSkgPT4gdm9pZDtcblxuXHQvLyBhcnJheSBvZiBxdWFkcyBhcyBkZXNjcmliZWQgYnkgY29tcHV0ZU1hcFByb2c7IG1hcC1rZXkgaXMgQU1EIG1hcCBrZXksIG1hcC12YWx1ZSBpcyBBTUQgbWFwIHZhbHVlXG5cdGxldCBtYXBQcm9ncmFtczogRG9qb0xvYWRlci5NYXBSb290ID0gW107XG5cblx0Ly8gQSBoYXNoOiAobWlkKSAtLT4gKG1vZHVsZS1vYmplY3QpIHRoZSBtb2R1bGUgbmFtZXNwYWNlXG5cdC8vXG5cdC8vIHBpZDogdGhlIHBhY2thZ2UgaWRlbnRpZmllciB0byB3aGljaCB0aGUgbW9kdWxlIGJlbG9uZ3MgKGUuZy4sIFwiZG9qb1wiKTsgXCJcIiBpbmRpY2F0ZXMgdGhlIHN5c3RlbSBvciBkZWZhdWx0XG5cdC8vIFx0cGFja2FnZVxuXHQvLyBtaWQ6IHRoZSBmdWxseS1yZXNvbHZlZCAoaS5lLiwgbWFwcGluZ3MgaGF2ZSBiZWVuIGFwcGxpZWQpIG1vZHVsZSBpZGVudGlmaWVyIHdpdGhvdXQgdGhlIHBhY2thZ2UgaWRlbnRpZmllclxuXHQvLyBcdChlLmcuLCBcImRvam8vaW8vc2NyaXB0XCIpXG5cdC8vIHVybDogdGhlIFVSTCBmcm9tIHdoaWNoIHRoZSBtb2R1bGUgd2FzIHJldHJpZXZlZFxuXHQvLyBwYWNrOiB0aGUgcGFja2FnZSBvYmplY3Qgb2YgdGhlIHBhY2thZ2UgdG8gd2hpY2ggdGhlIG1vZHVsZSBiZWxvbmdzXG5cdC8vIGV4ZWN1dGVkOiBmYWxzZSA9PiBub3QgZXhlY3V0ZWQ7IEVYRUNVVElORyA9PiBpbiB0aGUgcHJvY2VzcyBvZiB0cmFudmVyc2luZyBkZXBzIGFuZCBydW5uaW5nIGZhY3Rvcnk7XG5cdC8vIFx0dHJ1ZSA9PiBmYWN0b3J5IGhhcyBiZWVuIGV4ZWN1dGVkXG5cdC8vIGRlcHM6IHRoZSBkZXBlbmRlbmN5IGFycmF5IGZvciB0aGlzIG1vZHVsZSAoYXJyYXkgb2YgbW9kdWxlcyBvYmplY3RzKVxuXHQvLyBkZWY6IHRoZSBmYWN0b3J5IGZvciB0aGlzIG1vZHVsZVxuXHQvLyByZXN1bHQ6IHRoZSByZXN1bHQgb2YgdGhlIHJ1bm5pbmcgdGhlIGZhY3RvcnkgZm9yIHRoaXMgbW9kdWxlXG5cdC8vIGluamVjdGVkOiB0cnVlID0+IG1vZHVsZSBoYXMgYmVlbiBpbmplY3RlZFxuXHQvLyBsb2FkLCBub3JtYWxpemU6IHBsdWdpbiBmdW5jdGlvbnMgYXBwbGljYWJsZSBvbmx5IGZvciBwbHVnaW5zXG5cdC8vXG5cdC8vIE1vZHVsZXMgZ28gdGhyb3VnaCBzZXZlcmFsIHBoYXNlcyBpbiBjcmVhdGlvbjpcblx0Ly9cblx0Ly8gMS4gUmVxdWVzdGVkOiBzb21lIG90aGVyIG1vZHVsZSdzIGRlZmluaXRpb24gb3IgYSByZXF1aXJlIGFwcGxpY2F0aW9uIGNvbnRhaW5lZCB0aGUgcmVxdWVzdGVkIG1vZHVsZSBpblxuXHQvLyAgICBpdHMgZGVwZW5kZW5jeSBhcnJheVxuXHQvL1xuXHQvLyAyLiBJbmplY3RlZDogYSBzY3JpcHQgZWxlbWVudCBoYXMgYmVlbiBhcHBlbmRlZCB0byB0aGUgaW5zZXJ0LXBvaW50IGVsZW1lbnQgZGVtYW5kaW5nIHRoZSByZXNvdXJjZSBpbXBsaWVkIGJ5XG5cdC8vICAgIHRoZSBVUkxcblx0Ly9cblx0Ly8gMy4gTG9hZGVkOiB0aGUgcmVzb3VyY2UgaW5qZWN0ZWQgaW4gWzJdIGhhcyBiZWVuIGV2YWx1YXRlZC5cblx0Ly9cblx0Ly8gNC4gRGVmaW5lZDogdGhlIHJlc291cmNlIGNvbnRhaW5lZCBhIGRlZmluZSBzdGF0ZW1lbnQgdGhhdCBhZHZpc2VkIHRoZSBsb2FkZXIgYWJvdXQgdGhlIG1vZHVsZS5cblx0Ly9cblx0Ly8gNS4gRXZhbHVhdGVkOiB0aGUgbW9kdWxlIHdhcyBkZWZpbmVkIHZpYSBkZWZpbmUgYW5kIHRoZSBsb2FkZXIgaGFzIGV2YWx1YXRlZCB0aGUgZmFjdG9yeSBhbmQgY29tcHV0ZWQgYSByZXN1bHQuXG5cdGxldCBtb2R1bGVzOiB7IFsgbW9kdWxlSWQ6IHN0cmluZyBdOiBEb2pvTG9hZGVyLk1vZHVsZTsgfSA9IHt9O1xuXG5cdC8vIGxpc3Qgb2YgKGZyb20tcGF0aCwgdG8tcGF0aCwgcmVnZXgsIGxlbmd0aCkgZGVyaXZlZCBmcm9tIHBhdGhzO1xuXHQvLyBhIFwicHJvZ3JhbVwiIHRvIGFwcGx5IHBhdGhzOyBzZWUgY29tcHV0ZU1hcFByb2dcblx0bGV0IHBhdGhNYXBQcm9ncmFtczogRG9qb0xvYWRlci5QYXRoTWFwW10gPSBbXTtcblxuXHQvLyBoYXNoOiAobWlkIHwgdXJsKS0tPihmdW5jdGlvbiB8IHN0cmluZylcblx0Ly9cblx0Ly8gR2l2ZXMgYSBzZXQgb2YgY2FjaGUgbW9kdWxlcyBwZW5kaW5nIGVudHJ5IGludG8gY2FjaGUuIFdoZW4gY2FjaGVkIG1vZHVsZXMgYXJlIHB1Ymxpc2hlZCB0byB0aGUgbG9hZGVyLCB0aGV5IGFyZVxuXHQvLyBlbnRlcmVkIGludG8gcGVuZGluZ0NhY2hlSW5zZXJ0OyBtb2R1bGVzIGFyZSB0aGVuIHByZXNzZWQgaW50byBjYWNoZSB1cG9uICgxKSBBTUQgZGVmaW5lIG9yICgyKSB1cG9uIHJlY2VpdmluZ1xuXHQvLyBhbm90aGVyIGluZGVwZW5kZW50IHNldCBvZiBjYWNoZWQgbW9kdWxlcy4gKDEpIGlzIHRoZSB1c3VhbCBjYXNlLCBhbmQgdGhpcyBjYXNlIGFsbG93cyBub3JtYWxpemluZyBtaWRzIGdpdmVuXG5cdC8vIGluIHRoZSBwZW5kaW5nIGNhY2hlIGZvciB0aGUgbG9jYWwgY29uZmlndXJhdGlvbiwgcG9zc2libHkgcmVsb2NhdGluZyBtb2R1bGVzLlxuXHRsZXQgcGVuZGluZ0NhY2hlSW5zZXJ0OiB7IFttb2R1bGVJZDogc3RyaW5nXTogYW55OyB9ID0ge307XG5cblx0bGV0IHNldEdsb2JhbHM6IChyZXF1aXJlOiBEb2pvTG9hZGVyLlJvb3RSZXF1aXJlLCBkZWZpbmU6IERvam9Mb2FkZXIuRGVmaW5lKSA9PiB2b2lkO1xuXG5cdGxldCB1aWRHZW5lcmF0b3IgPSAwO1xuXG5cdC8vIHRoZSBudW1iZXIgb2YgbW9kdWxlcyB0aGUgbG9hZGVyIGhhcyBpbmplY3RlZCBidXQgaGFzIG5vdCBzZWVuIGRlZmluZWRcblx0bGV0IHdhaXRpbmdDb3VudCA9IDA7XG5cblx0Y29uc3QgaGFzOiBEb2pvTG9hZGVyLkhhcyA9IChmdW5jdGlvbiAoKTogRG9qb0xvYWRlci5IYXMge1xuXHRcdGNvbnN0IGhhc0NhY2hlOiB7IFsgbmFtZTogc3RyaW5nIF06IGFueTsgfSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdFx0Y29uc3QgZ2xvYmFsOiBXaW5kb3cgPSBnbG9iYWxPYmplY3Q7XG5cdFx0Y29uc3QgZG9jdW1lbnQ6IEhUTUxEb2N1bWVudCA9IGdsb2JhbC5kb2N1bWVudDtcblx0XHRjb25zdCBlbGVtZW50OiBIVE1MRGl2RWxlbWVudCA9IGRvY3VtZW50ICYmIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG5cdFx0Y29uc3QgaGFzOiBEb2pvTG9hZGVyLkhhcyA9IDxEb2pvTG9hZGVyLkhhcz4gZnVuY3Rpb24obmFtZTogc3RyaW5nKTogYW55IHtcblx0XHRcdHJldHVybiB0eXBlb2YgaGFzQ2FjaGVbbmFtZV0gPT09ICdmdW5jdGlvbicgP1xuXHRcdFx0XHQoaGFzQ2FjaGVbbmFtZV0gPSBoYXNDYWNoZVtuYW1lXShnbG9iYWwsIGRvY3VtZW50LCBlbGVtZW50KSkgOiBoYXNDYWNoZVtuYW1lXTtcblx0XHR9O1xuXG5cdFx0aGFzLmFkZCA9IGZ1bmN0aW9uIChuYW1lOiBzdHJpbmcsIHRlc3Q6IGFueSwgbm93OiBib29sZWFuLCBmb3JjZTogYm9vbGVhbik6IHZvaWQge1xuXHRcdFx0KCEobmFtZSBpbiBoYXNDYWNoZSkgfHwgZm9yY2UpICYmIChoYXNDYWNoZVtuYW1lXSA9IHRlc3QpO1xuXHRcdFx0bm93ICYmIGhhcyhuYW1lKTtcblx0XHR9O1xuXG5cdFx0cmV0dXJuIGhhcztcblx0fSkoKTtcblxuXHRjb25zdCByZXF1aXJlTW9kdWxlOiBEb2pvTG9hZGVyLlJvb3RSZXF1aXJlID1cblx0XHQ8RG9qb0xvYWRlci5Sb290UmVxdWlyZT4gZnVuY3Rpb24gKGRlcGVuZGVuY2llczogYW55LCBjYWxsYmFjaz86IERvam9Mb2FkZXIuUmVxdWlyZUNhbGxiYWNrKTogRG9qb0xvYWRlci5Nb2R1bGUge1xuXHRcdFx0cmV0dXJuIGNvbnRleHRSZXF1aXJlKGRlcGVuZGVuY2llcywgY2FsbGJhY2spO1xuXHRcdH07XG5cblx0Y29uc3QgbGlzdGVuZXJRdWV1ZXM6IHsgW3F1ZXVlOiBzdHJpbmddOiAoKC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkKVtdIH0gPSB7fTtcblxuXHRjb25zdCByZXBvcnRNb2R1bGVMb2FkRXJyb3IgPSBmdW5jdGlvbiAocGFyZW50OiBEb2pvTG9hZGVyLk1vZHVsZSwgbW9kdWxlOiBEb2pvTG9hZGVyLk1vZHVsZSwgdXJsOiBzdHJpbmcpOiB2b2lkIHtcblx0XHRjb25zdCBwYXJlbnRNaWQgPSAocGFyZW50ID8gYCAocGFyZW50OiAke3BhcmVudC5taWR9KWAgOiAnJyk7XG5cdFx0Y29uc3QgbWVzc2FnZSA9IGBGYWlsZWQgdG8gbG9hZCBtb2R1bGUgJHttb2R1bGUubWlkfSBmcm9tICR7dXJsfSR7cGFyZW50TWlkfWA7XG5cdFx0Y29uc3QgZXJyb3IgPSBtaXg8RG9qb0xvYWRlci5Mb2FkZXJFcnJvcj4obmV3IEVycm9yKG1lc3NhZ2UpLCB7XG5cdFx0XHRzcmM6ICdkb2pvL2xvYWRlcicsXG5cdFx0XHRpbmZvOiB7XG5cdFx0XHRcdG1vZHVsZSxcblx0XHRcdFx0dXJsLFxuXHRcdFx0XHRwYXJlbnRNaWRcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGlmICghZW1pdCgnZXJyb3InLCBlcnJvcikpIHsgdGhyb3cgZXJyb3I7IH07XG5cdH07XG5cblx0Y29uc3QgZW1pdCA9IGZ1bmN0aW9uKHR5cGU6IERvam9Mb2FkZXIuU2lnbmFsVHlwZSwgYXJnczoge30pOiBudW1iZXIgfCBib29sZWFuIHtcblx0XHRsZXQgcXVldWUgPSBsaXN0ZW5lclF1ZXVlc1t0eXBlXTtcblx0XHRsZXQgaGFzTGlzdGVuZXJzID0gcXVldWUgJiYgcXVldWUubGVuZ3RoO1xuXG5cdFx0aWYgKGhhc0xpc3RlbmVycykge1xuXHRcdFx0Zm9yIChsZXQgbGlzdGVuZXIgb2YgcXVldWUuc2xpY2UoMCkpIHtcblx0XHRcdFx0bGlzdGVuZXIuYXBwbHkobnVsbCwgQXJyYXkuaXNBcnJheShhcmdzKSA/IGFyZ3MgOiBbYXJnc10pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBoYXNMaXN0ZW5lcnM7XG5cdH07XG5cblx0Y29uc3Qgb24gPSBmdW5jdGlvbih0eXBlOiBzdHJpbmcsIGxpc3RlbmVyOiAoZXJyb3I6IERvam9Mb2FkZXIuTG9hZGVyRXJyb3IpID0+IHZvaWQpOiB7IHJlbW92ZTogKCkgPT4gdm9pZCB9IHtcblx0XHRsZXQgcXVldWUgPSBsaXN0ZW5lclF1ZXVlc1t0eXBlXSB8fCAobGlzdGVuZXJRdWV1ZXNbdHlwZV0gPSBbXSk7XG5cblx0XHRxdWV1ZS5wdXNoKGxpc3RlbmVyKTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHRyZW1vdmUoKTogdm9pZCB7XG5cdFx0XHRcdHF1ZXVlLnNwbGljZShxdWV1ZS5pbmRleE9mKGxpc3RlbmVyKSwgMSk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fTtcblxuXHRyZXF1aXJlTW9kdWxlLmhhcyA9IGhhcztcblx0cmVxdWlyZU1vZHVsZS5vbiA9IG9uO1xuXG5cdGhhcy5hZGQoJ2hvc3QtYnJvd3NlcicsIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGxvY2F0aW9uICE9PSAndW5kZWZpbmVkJyk7XG5cdGhhcy5hZGQoJ2hvc3Qtbm9kZScsIHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJiBwcm9jZXNzLnZlcnNpb25zICYmIHByb2Nlc3MudmVyc2lvbnMubm9kZSk7XG5cdGhhcy5hZGQoJ2hvc3QtbmFzaG9ybicsIHR5cGVvZiBsb2FkID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBQYWNrYWdlcyAhPT0gJ3VuZGVmaW5lZCcpO1xuXHRoYXMuYWRkKCdkZWJ1ZycsIHRydWUpO1xuXG5cdC8vIElFOSB3aWxsIHByb2Nlc3MgbXVsdGlwbGUgc2NyaXB0cyBhdCBvbmNlIGJlZm9yZSBmaXJpbmcgdGhlaXIgcmVzcGVjdGl2ZSBvbmxvYWQgZXZlbnRzLCBzbyBzb21lIGV4dHJhIHdvcmtcblx0Ly8gbmVlZHMgdG8gYmUgZG9uZSB0byBhc3NvY2lhdGUgdGhlIGNvbnRlbnQgb2YgdGhlIGRlZmluZSBjYWxsIHdpdGggdGhlIGNvcnJlY3Qgbm9kZS4gVGhpcyBpcyBrbm93biB0byBiZSBmaXhlZFxuXHQvLyBpbiBJRTEwIGFuZCB0aGUgYmFkIGJlaGF2aW91ciBjYW5ub3QgYmUgaW5mZXJyZWQgdGhyb3VnaCBmZWF0dXJlIGRldGVjdGlvbiwgc28gc2ltcGx5IHRhcmdldCB0aGlzIG9uZSB1c2VyLWFnZW50XG5cdGhhcy5hZGQoJ2xvYWRlci1pZTktY29tcGF0JywgaGFzKCdob3N0LWJyb3dzZXInKSAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ01TSUUgOS4wJykgPiAtMSk7XG5cblx0aGFzLmFkZCgnbG9hZGVyLWNvbmZpZ3VyYWJsZScsIHRydWUpO1xuXHRpZiAoaGFzKCdsb2FkZXItY29uZmlndXJhYmxlJykpIHtcblx0XHQvKipcblx0XHQgKiBDb25maWd1cmVzIHRoZSBsb2FkZXIuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge3sgP2Jhc2VVcmw6IHN0cmluZywgP21hcDogT2JqZWN0LCA/cGFja2FnZXM6IEFycmF5LjwoeyBuYW1lLCA/bG9jYXRpb24sID9tYWluIH18c3RyaW5nKT4gfX0gY29uZmlnXG5cdFx0ICogVGhlIGNvbmZpZ3VyYXRpb24gZGF0YS5cblx0XHQgKi9cblx0XHRyZXF1aXJlTW9kdWxlLmNvbmZpZyA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uOiBEb2pvTG9hZGVyLkNvbmZpZyk6IHZvaWQge1xuXHRcdFx0Ly8gTWFrZSBzdXJlIGJhc2VVcmwgZW5kcyBpbiBhIHNsYXNoXG5cdFx0XHRpZiAoY29uZmlndXJhdGlvbi5iYXNlVXJsKSB7XG5cdFx0XHRcdGNvbmZpZ3VyYXRpb24uYmFzZVVybCA9IGNvbmZpZ3VyYXRpb24uYmFzZVVybC5yZXBsYWNlKC9cXC8qJC8sICcvJyk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IG1lcmdlUHJvcHM6IERvam9Mb2FkZXIuT2JqZWN0TWFwID0ge1xuXHRcdFx0XHRwYXRoczogdHJ1ZSxcblx0XHRcdFx0YnVuZGxlczogdHJ1ZSxcblx0XHRcdFx0Y29uZmlnOiB0cnVlLFxuXHRcdFx0XHRtYXA6IHRydWVcblx0XHRcdH07XG5cblx0XHRcdC8vIENvcHkgY29uZmlndXJhdGlvbiBvdmVyIHRvIGNvbmZpZyBvYmplY3Rcblx0XHRcdGZvciAobGV0IGtleSBpbiBjb25maWd1cmF0aW9uKSB7XG5cdFx0XHRcdGNvbnN0IHZhbHVlID0gKDxEb2pvTG9hZGVyLk9iamVjdE1hcD4gY29uZmlndXJhdGlvbilba2V5XTtcblx0XHRcdFx0aWYgKG1lcmdlUHJvcHNba2V5XSkge1xuXHRcdFx0XHRcdGlmICghKDxEb2pvTG9hZGVyLk9iamVjdE1hcD4gY29uZmlnKVtrZXldKSB7XG5cdFx0XHRcdFx0XHQoPERvam9Mb2FkZXIuT2JqZWN0TWFwPiBjb25maWcpW2tleV0gPSB7fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bWl4KCg8RG9qb0xvYWRlci5PYmplY3RNYXA+IGNvbmZpZylba2V5XSwgdmFsdWUsIHRydWUpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdCg8RG9qb0xvYWRlci5PYmplY3RNYXA+IGNvbmZpZylba2V5XSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRPRE86IEV4cG9zZSBhbGwgcHJvcGVydGllcyBvbiByZXEgYXMgZ2V0dGVyL3NldHRlcnM/IFBsdWdpbiBtb2R1bGVzIGxpa2UgZG9qby9ub2RlIGJlaW5nIGFibGUgdG9cblx0XHRcdC8vIHJldHJpZXZlIGJhc2VVcmwgaXMgaW1wb3J0YW50LiBiYXNlVXJsIGlzIGRlZmluZWQgYXMgYSBnZXR0ZXIgY3VycmVudGx5LlxuXG5cdFx0XHRmb3JFYWNoKGNvbmZpZ3VyYXRpb24ucGFja2FnZXMsIGZ1bmN0aW9uIChwYWNrYWdlRGVzY3JpcHRvcjogRG9qb0xvYWRlci5QYWNrYWdlKTogdm9pZCB7XG5cdFx0XHRcdC8vIEFsbG93IHNob3J0aGFuZCBwYWNrYWdlIGRlZmluaXRpb24sIHdoZXJlIG5hbWUgYW5kIGxvY2F0aW9uIGFyZSB0aGUgc2FtZVxuXHRcdFx0XHRpZiAodHlwZW9mIHBhY2thZ2VEZXNjcmlwdG9yID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdHBhY2thZ2VEZXNjcmlwdG9yID0geyBuYW1lOiA8c3RyaW5nPiBwYWNrYWdlRGVzY3JpcHRvciwgbG9jYXRpb246IDxzdHJpbmc+IHBhY2thZ2VEZXNjcmlwdG9yIH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAocGFja2FnZURlc2NyaXB0b3IubG9jYXRpb24gIT0gbnVsbCkge1xuXHRcdFx0XHRcdHBhY2thZ2VEZXNjcmlwdG9yLmxvY2F0aW9uID0gcGFja2FnZURlc2NyaXB0b3IubG9jYXRpb24ucmVwbGFjZSgvXFwvKiQvLCAnLycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uZmlnLnBrZ3NbcGFja2FnZURlc2NyaXB0b3IubmFtZV0gPSBwYWNrYWdlRGVzY3JpcHRvcjtcblx0XHRcdH0pO1xuXG5cdFx0XHRmdW5jdGlvbiBjb21wdXRlTWFwUHJvZ3JhbShtYXA6IERvam9Mb2FkZXIuTW9kdWxlTWFwSXRlbSk6IERvam9Mb2FkZXIuTWFwSXRlbVtdIHtcblx0XHRcdFx0Ly8gVGhpcyBtZXRob2QgdGFrZXMgYSBtYXAgYXMgcmVwcmVzZW50ZWQgYnkgYSBKYXZhU2NyaXB0IG9iamVjdCBhbmQgaW5pdGlhbGl6ZXMgYW4gYXJyYXkgb2Zcblx0XHRcdFx0Ly8gYXJyYXlzIG9mIChtYXAta2V5LCBtYXAtdmFsdWUsIHJlZ2V4LWZvci1tYXAta2V5LCBsZW5ndGgtb2YtbWFwLWtleSksIHNvcnRlZCBkZWNyZWFzaW5nIGJ5IGxlbmd0aC1cblx0XHRcdFx0Ly8gb2YtbWFwLWtleS4gVGhlIHJlZ2V4IGxvb2tzIGZvciB0aGUgbWFwLWtleSBmb2xsb3dlZCBieSBlaXRoZXIgXCIvXCIgb3IgZW5kLW9mLXN0cmluZyBhdCB0aGUgYmVnaW5uaW5nXG5cdFx0XHRcdC8vIG9mIGEgdGhlIHNlYXJjaCBzb3VyY2UuXG5cdFx0XHRcdC8vXG5cdFx0XHRcdC8vIE1hcHMgbG9vayBsaWtlIHRoaXM6XG5cdFx0XHRcdC8vXG5cdFx0XHRcdC8vIG1hcDogeyBDOiB7IEQ6IEUgfSB9XG5cdFx0XHRcdC8vICAgIEFcdEJcblx0XHRcdFx0Ly9cblx0XHRcdFx0Ly8gVGhlIGNvbXB1dGVkIG1hcHBpbmcgaXMgYSA0LWFycmF5IGRlZXAgdHJlZSwgd2hlcmUgdGhlIG91dGVybW9zdCBhcnJheSBjb3JyZXNwb25kcyB0byB0aGUgc291cmNlXG5cdFx0XHRcdC8vIG1hcHBpbmcgb2JqZWN0IEEsIHRoZSAybmQgbGV2ZWwgYXJyYXlzIGVhY2ggY29ycmVzcG9uZCB0byBvbmUgb2YgdGhlIHNvdXJjZSBtYXBwaW5ncyBDIC0+IEIsIHRoZSAzcmRcblx0XHRcdFx0Ly8gbGV2ZWwgYXJyYXlzIGNvcnJlc3BvbmQgdG8gZWFjaCBkZXN0aW5hdGlvbiBtYXBwaW5nIG9iamVjdCBCLCBhbmQgdGhlIGlubmVybW9zdCBhcnJheXMgZWFjaFxuXHRcdFx0XHQvLyBjb3JyZXNwb25kIHRvIG9uZSBvZiB0aGUgZGVzdGluYXRpb24gbWFwcGluZ3MgRCAtPiBFLlxuXHRcdFx0XHQvL1xuXHRcdFx0XHQvLyBTbywgdGhlIG92ZXJhbGwgc3RydWN0dXJlIGxvb2tzIGxpa2UgdGhpczpcblx0XHRcdFx0Ly9cblx0XHRcdFx0Ly8gbWFwUHJvZ3JhbXMgPSBbIHNvdXJjZSBtYXBwaW5nIGFycmF5LCBzb3VyY2UgbWFwcGluZyBhcnJheSwgLi4uIF1cblx0XHRcdFx0Ly8gc291cmNlIG1hcHBpbmcgYXJyYXkgPSBbXG5cdFx0XHRcdC8vICAgICBzb3VyY2UgbW9kdWxlIGlkLFxuXHRcdFx0XHQvLyAgICAgWyBkZXN0aW5hdGlvbiBtYXBwaW5nIGFycmF5LCBkZXN0aW5hdGlvbiBtYXBwaW5nIGFycmF5LCAuLi4gXSxcblx0XHRcdFx0Ly8gICAgIFJlZ0V4cCB0aGF0IG1hdGNoZXMgb24gc291cmNlIG1vZHVsZSBpZCxcblx0XHRcdFx0Ly8gICAgIHNvdXJjZSBtb2R1bGUgaWQgbGVuZ3RoXG5cdFx0XHRcdC8vIF1cblx0XHRcdFx0Ly8gZGVzdGluYXRpb24gbWFwcGluZyBhcnJheSA9IFtcblx0XHRcdFx0Ly8gICAgIG9yaWdpbmFsIG1vZHVsZSBpZCxcblx0XHRcdFx0Ly8gICAgIGRlc3RpbmF0aW9uIG1vZHVsZSBpZCxcblx0XHRcdFx0Ly8gICAgIFJlZ0V4cCB0aGF0IG1hdGNoZXMgb24gb3JpZ2luYWwgbW9kdWxlIGlkLFxuXHRcdFx0XHQvLyAgICAgb3JpZ2luYWwgbW9kdWxlIGlkIGxlbmd0aFxuXHRcdFx0XHQvLyBdXG5cblx0XHRcdFx0Y29uc3QgcmVzdWx0OiBEb2pvTG9hZGVyLk1hcEl0ZW1bXSA9IFtdO1xuXG5cdFx0XHRcdGZvciAobGV0IG1vZHVsZUlkIGluIG1hcCkge1xuXHRcdFx0XHRcdGNvbnN0IHZhbHVlOiBhbnkgPSAoPGFueT4gbWFwKVttb2R1bGVJZF07XG5cdFx0XHRcdFx0Y29uc3QgaXNWYWx1ZUFNYXBSZXBsYWNlbWVudDogYm9vbGVhbiA9IHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCc7XG5cblx0XHRcdFx0XHRjb25zdCBpdGVtID0gPERvam9Mb2FkZXIuTWFwSXRlbT4ge1xuXHRcdFx0XHRcdFx0MDogbW9kdWxlSWQsXG5cdFx0XHRcdFx0XHQxOiBpc1ZhbHVlQU1hcFJlcGxhY2VtZW50ID8gY29tcHV0ZU1hcFByb2dyYW0odmFsdWUpIDogdmFsdWUsXG5cdFx0XHRcdFx0XHQyOiBuZXcgUmVnRXhwKCdeJyArIG1vZHVsZUlkLnJlcGxhY2UoL1stXFxbXFxde30oKSorPy4sXFxcXFxcXiR8I1xcc10vZywgJ1xcXFwkJicpICsgJyg/OlxcL3wkKScpLFxuXHRcdFx0XHRcdFx0MzogbW9kdWxlSWQubGVuZ3RoXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRyZXN1bHQucHVzaChpdGVtKTtcblxuXHRcdFx0XHRcdGlmIChpc1ZhbHVlQU1hcFJlcGxhY2VtZW50ICYmIG1vZHVsZUlkID09PSAnKicpIHtcblx0XHRcdFx0XHRcdCg8RG9qb0xvYWRlci5NYXBSb290PiByZXN1bHQpLnN0YXIgPSBpdGVtWzFdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJlc3VsdC5zb3J0KGZ1bmN0aW9uIChsZWZ0OiBEb2pvTG9hZGVyLk1hcEl0ZW0sIHJpZ2h0OiBEb2pvTG9hZGVyLk1hcEl0ZW0pOiBudW1iZXIge1xuXHRcdFx0XHRcdHJldHVybiByaWdodFszXSAtIGxlZnRbM107XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZJWE1FIHRoaXMgaXMgYSBkb3duLWNhc3QuXG5cdFx0XHQvLyBjb21wdXRlTWFwUHJvZ3JhbSA9PiBNYXBJdGVtW10gPT4gbWFwUHJvZ3JhbXM6IE1hcFNvdXJjZVtdXG5cdFx0XHQvLyBNYXBTb3VyY2VbMV0gPT4gTWFwUmVwbGFjZW1lbnRbXSBpcyBtb3JlIHNwZWNpZmljIHRoYW4gTWFwSXRlbXNbMV0gPT4gYW55XG5cdFx0XHRtYXBQcm9ncmFtcyA9IGNvbXB1dGVNYXBQcm9ncmFtKGNvbmZpZy5tYXApO1xuXG5cdFx0XHQvLyBOb3RlIHRoYXQgb2xkIHBhdGhzIHdpbGwgZ2V0IGRlc3Ryb3llZCBpZiByZWNvbmZpZ3VyZWRcblx0XHRcdGNvbmZpZ3VyYXRpb24ucGF0aHMgJiYgKHBhdGhNYXBQcm9ncmFtcyA9IGNvbXB1dGVNYXBQcm9ncmFtKGNvbmZpZ3VyYXRpb24ucGF0aHMpKTtcblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gZm9yRWFjaDxUPihhcnJheTogVFtdLCBjYWxsYmFjazogKHZhbHVlOiBULCBpbmRleDogbnVtYmVyLCBhcnJheTogVFtdKSA9PiB2b2lkKTogdm9pZCB7XG5cdFx0YXJyYXkgJiYgYXJyYXkuZm9yRWFjaChjYWxsYmFjayk7XG5cdH1cblxuXHRmdW5jdGlvbiBtaXg8VCBleHRlbmRzIHt9Pih0YXJnZXQ6IHt9LCBzb3VyY2U6IHt9LCBkZWVwPzogYm9vbGVhbik6IFQge1xuXHRcdGlmIChzb3VyY2UpIHtcblx0XHRcdGZvciAobGV0IGtleSBpbiBzb3VyY2UpIHtcblx0XHRcdFx0bGV0IHNvdXJjZVZhbHVlID0gKDxEb2pvTG9hZGVyLk9iamVjdE1hcD4gc291cmNlKVtrZXldO1xuXG5cdFx0XHRcdGlmIChkZWVwICYmIHR5cGVvZiBzb3VyY2VWYWx1ZSA9PT0gJ29iamVjdCcgJiZcblx0XHRcdFx0XHQhQXJyYXkuaXNBcnJheShzb3VyY2VWYWx1ZSkgJiYgIShzb3VyY2VWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkpIHtcblxuXHRcdFx0XHRcdGlmICghKDxEb2pvTG9hZGVyLk9iamVjdE1hcD4gdGFyZ2V0KVtrZXldKSB7XG5cdFx0XHRcdFx0XHQoPERvam9Mb2FkZXIuT2JqZWN0TWFwPiB0YXJnZXQpW2tleV0gPSB7fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bWl4KCg8RG9qb0xvYWRlci5PYmplY3RNYXA+IHRhcmdldClba2V5XSwgc291cmNlVmFsdWUsIHRydWUpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdCg8RG9qb0xvYWRlci5PYmplY3RNYXA+IHRhcmdldClba2V5XSA9IHNvdXJjZVZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiA8VD4gdGFyZ2V0O1xuXHR9XG5cblx0ZnVuY3Rpb24gY29uc3VtZVBlbmRpbmdDYWNoZUluc2VydChyZWZlcmVuY2VNb2R1bGU/OiBEb2pvTG9hZGVyLk1vZHVsZSk6IHZvaWQge1xuXHRcdGxldCBpdGVtOiBhbnk7XG5cblx0XHRmb3IgKGxldCBrZXkgaW4gcGVuZGluZ0NhY2hlSW5zZXJ0KSB7XG5cdFx0XHRpdGVtID0gcGVuZGluZ0NhY2hlSW5zZXJ0W2tleV07XG5cblx0XHRcdGNhY2hlW1xuXHRcdFx0XHR0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycgPyB0b1VybChrZXksIHJlZmVyZW5jZU1vZHVsZSkgOiBnZXRNb2R1bGVJbmZvcm1hdGlvbihrZXksIHJlZmVyZW5jZU1vZHVsZSkubWlkXG5cdFx0XHRdID0gaXRlbTtcblx0XHR9XG5cblx0XHRwZW5kaW5nQ2FjaGVJbnNlcnQgPSB7fTtcblx0fVxuXG5cdGZ1bmN0aW9uIG5vb3AoKTogdm9pZCB7fTtcblxuXHRsZXQgbG9hZE5vZGVNb2R1bGU6IChtb2R1bGVJZDogc3RyaW5nLCBwYXJlbnQ/OiBEb2pvTG9hZGVyLk1vZHVsZSkgPT4gYW55ID0gbm9vcDtcblxuXHRmdW5jdGlvbiBjb250ZXh0UmVxdWlyZShtb2R1bGVJZDogc3RyaW5nLCB1bnVzZWQ/OiB2b2lkLCByZWZlcmVuY2VNb2R1bGU/OiBEb2pvTG9hZGVyLk1vZHVsZSk6IERvam9Mb2FkZXIuTW9kdWxlO1xuXHRmdW5jdGlvbiBjb250ZXh0UmVxdWlyZShkZXBlbmRlbmNpZXM6IHN0cmluZ1tdLCBjYWxsYmFjazogRG9qb0xvYWRlci5SZXF1aXJlQ2FsbGJhY2ssIHJlZmVyZW5jZU1vZHVsZT86IERvam9Mb2FkZXIuTW9kdWxlKTogRG9qb0xvYWRlci5Nb2R1bGU7XG5cdGZ1bmN0aW9uIGNvbnRleHRSZXF1aXJlKGRlcGVuZGVuY2llczogc3RyaW5nIHwgc3RyaW5nW10sIGNhbGxiYWNrOiBhbnksIHJlZmVyZW5jZU1vZHVsZT86IERvam9Mb2FkZXIuTW9kdWxlKTogRG9qb0xvYWRlci5Nb2R1bGUge1xuXHRcdGxldCBtb2R1bGU6IERvam9Mb2FkZXIuTW9kdWxlO1xuXHRcdGlmICh0eXBlb2YgZGVwZW5kZW5jaWVzID09PSAnc3RyaW5nJykge1xuXHRcdFx0bW9kdWxlID0gZ2V0TW9kdWxlKGRlcGVuZGVuY2llcywgcmVmZXJlbmNlTW9kdWxlKTtcblx0XHRcdGlmIChtb2R1bGUuZXhlY3V0ZWQgIT09IHRydWUgJiYgbW9kdWxlLmV4ZWN1dGVkICE9PSBFWEVDVVRJTkcpIHtcblx0XHRcdFx0aWYgKGhhcygnaG9zdC1ub2RlJykgJiYgIW1vZHVsZS5wbHVnaW4pIHtcblx0XHRcdFx0XHRsZXQgcmVzdWx0ID0gbG9hZE5vZGVNb2R1bGUobW9kdWxlLm1pZCwgcmVmZXJlbmNlTW9kdWxlKTtcblx0XHRcdFx0XHRpZiAocmVzdWx0KSB7XG5cdFx0XHRcdFx0XHRpbml0aWFsaXplTW9kdWxlKG1vZHVsZSwgW10sIG51bGwpO1xuXHRcdFx0XHRcdFx0bW9kdWxlLnJlc3VsdCA9IHJlc3VsdDtcblx0XHRcdFx0XHRcdG1vZHVsZS5janMuc2V0RXhwb3J0cyhyZXN1bHQpO1xuXHRcdFx0XHRcdFx0bW9kdWxlLmV4ZWN1dGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdG1vZHVsZS5pbmplY3RlZCA9IHRydWU7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignQXR0ZW1wdCB0byByZXF1aXJlIHVubG9hZGVkIG1vZHVsZSAnICsgbW9kdWxlLm1pZCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKG1vZHVsZS5wbHVnaW4pIHtcblx0XHRcdFx0XHRpbmplY3RNb2R1bGUobW9kdWxlLCBudWxsKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIG1vZHVsZSB0byBgbW9kdWxlYFxuXHRcdFx0Ly8gb3RoZXJ3aXNlIHJlcXVpcmUoJ21vZHVsZUlkJykgcmV0dXJucyB0aGUgaW50ZXJuYWxcblx0XHRcdC8vIG1vZHVsZSByZXByZXNlbnRhdGlvblxuXHRcdFx0bW9kdWxlID0gbW9kdWxlLnJlc3VsdDtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoQXJyYXkuaXNBcnJheShkZXBlbmRlbmNpZXMpKSB7XG5cdFx0XHQvLyBzaWduYXR1cmUgaXMgKHJlcXVlc3RMaXN0IFssY2FsbGJhY2tdKVxuXHRcdFx0Ly8gY29uc3RydWN0IGEgc3ludGhldGljIG1vZHVsZSB0byBjb250cm9sIGV4ZWN1dGlvbiBvZiB0aGUgcmVxdWVzdExpc3QsIGFuZCwgb3B0aW9uYWxseSwgY2FsbGJhY2tcblx0XHRcdG1vZHVsZSA9IGdldE1vZHVsZUluZm9ybWF0aW9uKCcqJyArICgrK3VpZEdlbmVyYXRvcikpO1xuXHRcdFx0bWl4KG1vZHVsZSwge1xuXHRcdFx0XHRkZXBzOiByZXNvbHZlRGVwZW5kZW5jaWVzKGRlcGVuZGVuY2llcywgbW9kdWxlLCByZWZlcmVuY2VNb2R1bGUpLFxuXHRcdFx0XHRkZWY6IGNhbGxiYWNrIHx8IHt9LFxuXHRcdFx0XHRnYzogdHJ1ZSAvLyBnYXJiYWdlIGNvbGxlY3Rcblx0XHRcdH0pO1xuXHRcdFx0Z3VhcmRDaGVja0NvbXBsZXRlKGZ1bmN0aW9uICgpOiB2b2lkIHtcblx0XHRcdFx0Zm9yRWFjaChtb2R1bGUuZGVwcywgaW5qZWN0TW9kdWxlLmJpbmQobnVsbCwgbW9kdWxlKSk7XG5cdFx0XHR9KTtcblx0XHRcdGV4ZWN1dGlvblF1ZXVlLnB1c2gobW9kdWxlKTtcblx0XHRcdGNoZWNrQ29tcGxldGUoKTtcblx0XHR9XG5cdFx0cmV0dXJuIG1vZHVsZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZVJlcXVpcmUobW9kdWxlOiBEb2pvTG9hZGVyLk1vZHVsZSk6IERvam9Mb2FkZXIuUmVxdWlyZSB7XG5cdFx0bGV0IHJlc3VsdDogRG9qb0xvYWRlci5SZXF1aXJlID0gKCFtb2R1bGUgJiYgcmVxdWlyZU1vZHVsZSkgfHwgbW9kdWxlLnJlcXVpcmU7XG5cdFx0aWYgKCFyZXN1bHQpIHtcblx0XHRcdG1vZHVsZS5yZXF1aXJlID0gcmVzdWx0ID0gPERvam9Mb2FkZXIuUmVxdWlyZT4gZnVuY3Rpb24gKGRlcGVuZGVuY2llczogYW55LCBjYWxsYmFjazogYW55KTogRG9qb0xvYWRlci5Nb2R1bGUge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dFJlcXVpcmUoZGVwZW5kZW5jaWVzLCBjYWxsYmFjaywgbW9kdWxlKTtcblx0XHRcdH07XG5cdFx0XHRtaXgobWl4KHJlc3VsdCwgcmVxdWlyZU1vZHVsZSksIHtcblx0XHRcdFx0dG9Vcmw6IGZ1bmN0aW9uIChuYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuXHRcdFx0XHRcdHJldHVybiB0b1VybChuYW1lLCBtb2R1bGUpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR0b0Fic01pZDogZnVuY3Rpb24gKG1pZDogc3RyaW5nKTogc3RyaW5nIHtcblx0XHRcdFx0XHRyZXR1cm4gdG9BYnNNaWQobWlkLCBtb2R1bGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdGZ1bmN0aW9uIHJ1bk1hcFByb2dyYW0odGFyZ2V0TW9kdWxlSWQ6IHN0cmluZywgbWFwOiBEb2pvTG9hZGVyLk1hcEl0ZW1bXSk6IERvam9Mb2FkZXIuTWFwU291cmNlIHtcblx0XHQvLyBzZWFyY2ggZm9yIHRhcmdldE1vZHVsZUlkIGluIG1hcDsgcmV0dXJuIHRoZSBtYXAgaXRlbSBpZiBmb3VuZDsgZmFsc3kgb3RoZXJ3aXNlXG5cdFx0aWYgKG1hcCkge1xuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGogPSBtYXAubGVuZ3RoOyBpIDwgajsgKytpKSB7XG5cdFx0XHRcdGlmIChtYXBbaV1bMl0udGVzdCh0YXJnZXRNb2R1bGVJZCkpIHtcblx0XHRcdFx0XHRyZXR1cm4gbWFwW2ldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRmdW5jdGlvbiBjb21wYWN0UGF0aChwYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuXHRcdGNvbnN0IHBhdGhTZWdtZW50czogc3RyaW5nW10gPSBwYXRoLnJlcGxhY2UoL1xcXFwvZywgJy8nKS5zcGxpdCgnLycpO1xuXHRcdGxldCBhYnNvbHV0ZVBhdGhTZWdtZW50czogc3RyaW5nW10gPSBbXTtcblx0XHRsZXQgc2VnbWVudDogc3RyaW5nO1xuXHRcdGxldCBsYXN0U2VnbWVudDogc3RyaW5nO1xuXG5cdFx0d2hpbGUgKHBhdGhTZWdtZW50cy5sZW5ndGgpIHtcblx0XHRcdHNlZ21lbnQgPSBwYXRoU2VnbWVudHMuc2hpZnQoKTtcblx0XHRcdGlmIChzZWdtZW50ID09PSAnLi4nICYmIGFic29sdXRlUGF0aFNlZ21lbnRzLmxlbmd0aCAmJiBsYXN0U2VnbWVudCAhPT0gJy4uJykge1xuXHRcdFx0XHRhYnNvbHV0ZVBhdGhTZWdtZW50cy5wb3AoKTtcblx0XHRcdFx0bGFzdFNlZ21lbnQgPSBhYnNvbHV0ZVBhdGhTZWdtZW50c1thYnNvbHV0ZVBhdGhTZWdtZW50cy5sZW5ndGggLSAxXTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKHNlZ21lbnQgIT09ICcuJykge1xuXHRcdFx0XHRhYnNvbHV0ZVBhdGhTZWdtZW50cy5wdXNoKChsYXN0U2VnbWVudCA9IHNlZ21lbnQpKTtcblx0XHRcdH0gLy8gZWxzZSBpZ25vcmUgXCIuXCJcblx0XHR9XG5cblx0XHRyZXR1cm4gYWJzb2x1dGVQYXRoU2VnbWVudHMuam9pbignLycpO1xuXHR9XG5cblx0ZnVuY3Rpb24gdXBkYXRlTW9kdWxlSWRGcm9tTWFwKG1vZHVsZUlkOiBzdHJpbmcsIHJlZmVyZW5jZU1vZHVsZT86IERvam9Mb2FkZXIuTW9kdWxlKTogc3RyaW5nIHtcblx0XHQvLyByZWxhdGl2ZSBtb2R1bGUgaWRzIGFyZSByZWxhdGl2ZSB0byB0aGUgcmVmZXJlbmNlTW9kdWxlOyBnZXQgcmlkIG9mIGFueSBkb3RzXG5cdFx0bW9kdWxlSWQgPSBjb21wYWN0UGF0aCgvXlxcLi8udGVzdChtb2R1bGVJZCkgJiYgcmVmZXJlbmNlTW9kdWxlID9cblx0XHRcdChyZWZlcmVuY2VNb2R1bGUubWlkICsgJy8uLi8nICsgbW9kdWxlSWQpIDogbW9kdWxlSWQpO1xuXHRcdC8vIGF0IHRoaXMgcG9pbnQsIG1vZHVsZUlkIGlzIGFuIGFic29sdXRlIG1vZHVsZUlkXG5cblx0XHQvLyBpZiB0aGVyZSBpcyBhIHJlZmVyZW5jZSBtb2R1bGUsIHRoZW4gdXNlIGl0cyBtb2R1bGUgbWFwLCBpZiBvbmUgZXhpc3RzOyBvdGhlcndpc2UsIHVzZSB0aGUgZ2xvYmFsIG1hcC5cblx0XHQvLyBzZWUgY29tcHV0ZU1hcFByb2cgZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlIHN0cnVjdHVyZSBvZiB0aGUgbWFwIGFycmF5c1xuXHRcdGxldCBtb2R1bGVNYXA6IERvam9Mb2FkZXIuTWFwSXRlbSA9IHJlZmVyZW5jZU1vZHVsZSAmJiBydW5NYXBQcm9ncmFtKHJlZmVyZW5jZU1vZHVsZS5taWQsIG1hcFByb2dyYW1zKTtcblx0XHRtb2R1bGVNYXAgPSBtb2R1bGVNYXAgPyBtb2R1bGVNYXBbMV0gOiBtYXBQcm9ncmFtcy5zdGFyO1xuXG5cdFx0bGV0IG1hcEl0ZW06IERvam9Mb2FkZXIuTWFwSXRlbTtcblx0XHRpZiAoKG1hcEl0ZW0gPSBydW5NYXBQcm9ncmFtKG1vZHVsZUlkLCBtb2R1bGVNYXApKSkge1xuXHRcdFx0bW9kdWxlSWQgPSBtYXBJdGVtWzFdICsgbW9kdWxlSWQuc2xpY2UobWFwSXRlbVszXSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1vZHVsZUlkO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0UGx1Z2luSW5mb3JtYXRpb24obW9kdWxlSWQ6IHN0cmluZywgbWF0Y2g6IHN0cmluZ1tdLCByZWZlcmVuY2VNb2R1bGU/OiBEb2pvTG9hZGVyLk1vZHVsZSk6IERvam9Mb2FkZXIuTW9kdWxlIHtcblx0XHRjb25zdCBwbHVnaW4gPSBnZXRNb2R1bGUobWF0Y2hbMV0sIHJlZmVyZW5jZU1vZHVsZSk7XG5cdFx0Y29uc3QgaXNQbHVnaW5Mb2FkZWQgPSBCb29sZWFuKHBsdWdpbi5sb2FkKTtcblxuXHRcdGNvbnN0IGNvbnRleHRSZXF1aXJlID0gY3JlYXRlUmVxdWlyZShyZWZlcmVuY2VNb2R1bGUpO1xuXG5cdFx0bGV0IHBsdWdpblJlc291cmNlSWQ6IHN0cmluZztcblx0XHRpZiAoaXNQbHVnaW5Mb2FkZWQpIHtcblx0XHRcdHBsdWdpblJlc291cmNlSWQgPSByZXNvbHZlUGx1Z2luUmVzb3VyY2VJZChwbHVnaW4sIG1hdGNoWzJdLCBjb250ZXh0UmVxdWlyZSk7XG5cdFx0XHRtb2R1bGVJZCA9IChwbHVnaW4ubWlkICsgJyEnICsgcGx1Z2luUmVzb3VyY2VJZCk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gaWYgbm90IGxvYWRlZCwgbmVlZCB0byBtYXJrIGluIGEgd2F5IHRoYXQgaXQgd2lsbCBnZXQgcHJvcGVybHkgcmVzb2x2ZWQgbGF0ZXJcblx0XHRcdHBsdWdpblJlc291cmNlSWQgPSBtYXRjaFsyXTtcblx0XHRcdG1vZHVsZUlkID0gcGx1Z2luLm1pZCArICchJyArICgrK3VpZEdlbmVyYXRvcikgKyAnISonO1xuXHRcdH1cblx0XHRyZXR1cm4gPERvam9Mb2FkZXIuTW9kdWxlPiA8YW55PiB7XG5cdFx0XHRwbHVnaW46IHBsdWdpbixcblx0XHRcdG1pZDogbW9kdWxlSWQsXG5cdFx0XHRyZXE6IGNvbnRleHRSZXF1aXJlLFxuXHRcdFx0cHJpZDogcGx1Z2luUmVzb3VyY2VJZCxcblx0XHRcdGZpeDogIWlzUGx1Z2luTG9hZGVkXG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldE1vZHVsZUluZm9ybWF0aW9uKG1vZHVsZUlkOiBzdHJpbmcsIHJlZmVyZW5jZU1vZHVsZT86IERvam9Mb2FkZXIuTW9kdWxlKTogRG9qb0xvYWRlci5Nb2R1bGUge1xuXHRcdGxldCBtYXRjaCA9IG1vZHVsZUlkLm1hdGNoKC9eKFteXFwvXSspKFxcLyguKykpPyQvKTtcblx0XHRsZXQgcGFja2FnZUlkID0gbWF0Y2ggPyBtYXRjaFsxXSA6ICcnO1xuXHRcdGxldCBwYWNrID0gY29uZmlnLnBrZ3NbcGFja2FnZUlkXTtcblx0XHRsZXQgbW9kdWxlSWRJblBhY2thZ2U6IHN0cmluZztcblxuXHRcdGlmIChwYWNrKSB7XG5cdFx0XHRtb2R1bGVJZCA9IHBhY2thZ2VJZCArICcvJyArIChtb2R1bGVJZEluUGFja2FnZSA9IChtYXRjaFszXSB8fCBwYWNrLm1haW4gfHwgJ21haW4nKSk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0cGFja2FnZUlkID0gJyc7XG5cdFx0fVxuXG5cdFx0bGV0IG1vZHVsZSA9IG1vZHVsZXNbbW9kdWxlSWRdO1xuXHRcdGlmICghKG1vZHVsZSkpIHtcblx0XHRcdGxldCBtYXBJdGVtID0gcnVuTWFwUHJvZ3JhbShtb2R1bGVJZCwgcGF0aE1hcFByb2dyYW1zKTtcblx0XHRcdGxldCB1cmwgPSBtYXBJdGVtID8gbWFwSXRlbVsxXSArIG1vZHVsZUlkLnNsaWNlKG1hcEl0ZW1bM10pIDogKHBhY2thZ2VJZCA/IHBhY2subG9jYXRpb24gKyBtb2R1bGVJZEluUGFja2FnZSA6IG1vZHVsZUlkKTtcblx0XHRcdG1vZHVsZSA9IDxEb2pvTG9hZGVyLk1vZHVsZT4gPGFueT4ge1xuXHRcdFx0XHRwaWQ6IHBhY2thZ2VJZCxcblx0XHRcdFx0bWlkOiBtb2R1bGVJZCxcblx0XHRcdFx0cGFjazogcGFjayxcblx0XHRcdFx0dXJsOiBjb21wYWN0UGF0aChcblx0XHRcdFx0XHQvLyBhYnNvbHV0ZSB1cmxzIHNob3VsZCBub3QgYmUgcHJlZml4ZWQgd2l0aCBiYXNlVXJsXG5cdFx0XHRcdFx0KC9eKD86XFwvfFxcdys6KS8udGVzdCh1cmwpID8gJycgOiBjb25maWcuYmFzZVVybCkgK1xuXHRcdFx0XHRcdHVybCArXG5cdFx0XHRcdFx0Ly8gdXJscyB3aXRoIGEgamF2YXNjcmlwdCBleHRlbnNpb24gc2hvdWxkIG5vdCBoYXZlIGFub3RoZXIgb25lIGFkZGVkXG5cdFx0XHRcdFx0KC9cXC5qcyg/OlxcP1teP10qKT8kLy50ZXN0KHVybCkgPyAnJyA6ICcuanMnKVxuXHRcdFx0XHQpXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHJldHVybiBtb2R1bGU7XG5cdH1cblxuXHRmdW5jdGlvbiByZXNvbHZlUGx1Z2luUmVzb3VyY2VJZChwbHVnaW46IERvam9Mb2FkZXIuTW9kdWxlLCBwbHVnaW5SZXNvdXJjZUlkOiBzdHJpbmcsIGNvbnRleHRSZXF1aXJlOiBEb2pvTG9hZGVyLlJlcXVpcmUpOiBzdHJpbmcge1xuXHRcdHJldHVybiBwbHVnaW4ubm9ybWFsaXplID8gcGx1Z2luLm5vcm1hbGl6ZShwbHVnaW5SZXNvdXJjZUlkLCBjb250ZXh0UmVxdWlyZS50b0Fic01pZCkgOlxuXHRcdFx0Y29udGV4dFJlcXVpcmUudG9BYnNNaWQocGx1Z2luUmVzb3VyY2VJZCk7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRNb2R1bGUobW9kdWxlSWQ6IHN0cmluZywgcmVmZXJlbmNlTW9kdWxlPzogRG9qb0xvYWRlci5Nb2R1bGUpOiBEb2pvTG9hZGVyLk1vZHVsZSB7XG5cdFx0Ly8gY29tcHV0ZSBhbmQgY29uc3RydWN0IChpZiBuZWNlc3NhcnkpIHRoZSBtb2R1bGUgaW1wbGllZCBieSB0aGUgbW9kdWxlSWQgd2l0aCByZXNwZWN0IHRvIHJlZmVyZW5jZU1vZHVsZVxuXHRcdGxldCBtb2R1bGU6IERvam9Mb2FkZXIuTW9kdWxlO1xuXHRcdGNvbnN0IHBsdWdpblJlZ0V4ID0gL14oLis/KVxcISguKikkLztcblxuXHRcdC8vIEZvcmVzZWFibGUgc2l0dWF0aW9ucyAod2hlcmUgPy0+IGlzIGEgbWFwIGxvb2t1cCBmdW5jdGlvbilcblx0XHQvLyBtb2R1bGVcblx0XHQvLyBwbHVnaW4hYXJnXG5cdFx0Ly8gbW9kdWxlID8tPiBtYXBwZWRNb2R1bGVcblx0XHQvLyBtb2R1bGUgPy0+IG1hcHBlZFBsdWdpbiFhcmdcblx0XHQvLyBwbHVnaW4hYXJnID8tPiBtYXBwZWRQbHVnaW4gKyAhICsgYXJnXG5cblx0XHQvLyBEbyBpbml0YWwgY2hlY2sgb24gdGhlIHBhc3NlZCBpbiBtb2R1bGVJZFxuXHRcdGNvbnN0IHBhc3NlZE1vZHVsZU1hdGNoID0gbW9kdWxlSWQubWF0Y2gocGx1Z2luUmVnRXgpO1xuXHRcdGlmIChwYXNzZWRNb2R1bGVNYXRjaCkge1xuXHRcdFx0Ly8gUGFzc2VkIGluIG1vZHVsZUlkIGlzIGEgcGx1Z2luLCBzbyBjaGVjayB0aGUgbWFwIHVzaW5nIG9ubHkgdGhlIHBsdWdpbiBuYW1lXG5cdFx0XHQvLyB0aGVuIHJlY29uc3RydWN0IHVzaW5nIHRoZSBwbHVnaW5BcmdzXG5cdFx0XHRsZXQgcGx1Z2luSWQ6IHN0cmluZyA9IHVwZGF0ZU1vZHVsZUlkRnJvbU1hcChwYXNzZWRNb2R1bGVNYXRjaFsxXSwgcmVmZXJlbmNlTW9kdWxlKTtcblx0XHRcdG1vZHVsZUlkID0gYCR7cGx1Z2luSWR9ISR7cGFzc2VkTW9kdWxlTWF0Y2hbMl19YDtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHQvLyBOb3QgYSBtb2R1bGUsIHNvIGNoZWNrIHRoZSBtYXAgdXNpbmcgdGhlIGZ1bGwgbW9kdWxlSWQgcGFzc2VkXG5cdFx0XHRtb2R1bGVJZCA9IHVwZGF0ZU1vZHVsZUlkRnJvbU1hcChtb2R1bGVJZCwgcmVmZXJlbmNlTW9kdWxlKTtcblx0XHR9XG5cblx0XHQvLyBEbyBmaW5hbCBjaGVjayBvbiB0aGUgbWFwcGVkIG1vZHVsZSAvIHBsdWdpbiBJZCB0byBzZWUgd2hhdCB3ZSdyZSBkZWFsaW5nIHdpdGhcblx0XHRjb25zdCBtYXBwZWRNb2R1bGVNYXRjaCA9IG1vZHVsZUlkLm1hdGNoKHBsdWdpblJlZ0V4KTtcblx0XHRpZiAobWFwcGVkTW9kdWxlTWF0Y2gpIHtcblx0XHRcdG1vZHVsZSA9IGdldFBsdWdpbkluZm9ybWF0aW9uKG1vZHVsZUlkLCBtYXBwZWRNb2R1bGVNYXRjaCwgcmVmZXJlbmNlTW9kdWxlKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRtb2R1bGUgPSBnZXRNb2R1bGVJbmZvcm1hdGlvbihtb2R1bGVJZCwgcmVmZXJlbmNlTW9kdWxlKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbW9kdWxlc1ttb2R1bGUubWlkXSB8fCAobW9kdWxlc1ttb2R1bGUubWlkXSA9IG1vZHVsZSk7XG5cdH1cblxuXHRmdW5jdGlvbiB0b0Fic01pZChtb2R1bGVJZDogc3RyaW5nLCByZWZlcmVuY2VNb2R1bGU6IERvam9Mb2FkZXIuTW9kdWxlKTogc3RyaW5nIHtcblx0XHRtb2R1bGVJZCA9IHVwZGF0ZU1vZHVsZUlkRnJvbU1hcChtb2R1bGVJZCwgcmVmZXJlbmNlTW9kdWxlKTtcblx0XHRyZXR1cm4gZ2V0TW9kdWxlSW5mb3JtYXRpb24obW9kdWxlSWQsIHJlZmVyZW5jZU1vZHVsZSkubWlkO1xuXHR9XG5cblx0ZnVuY3Rpb24gdG9VcmwobmFtZTogc3RyaW5nLCByZWZlcmVuY2VNb2R1bGU6IERvam9Mb2FkZXIuTW9kdWxlKTogc3RyaW5nIHtcblx0XHRsZXQgbW9kdWxlSWQgPSBuYW1lICsgJy94Jztcblx0XHRtb2R1bGVJZCA9IHVwZGF0ZU1vZHVsZUlkRnJvbU1hcChtb2R1bGVJZCwgcmVmZXJlbmNlTW9kdWxlKTtcblx0XHRjb25zdCBtb2R1bGVJbmZvOiBEb2pvTG9hZGVyLk1vZHVsZSA9IGdldE1vZHVsZUluZm9ybWF0aW9uKG1vZHVsZUlkLCByZWZlcmVuY2VNb2R1bGUpO1xuXHRcdGNvbnN0IHVybDogc3RyaW5nID0gbW9kdWxlSW5mby51cmw7XG5cblx0XHQvLyBcIi94LmpzXCIgc2luY2UgZ2V0TW9kdWxlSW5mbyBhdXRvbWF0aWNhbGx5IGFwcGVuZHMgXCIuanNcIiBhbmQgd2UgYXBwZW5kZWQgXCIveFwiIHRvIG1ha2UgbmFtZSBsb29rIGxpa2UgYVxuXHRcdC8vIG1vZHVsZSBpZFxuXHRcdHJldHVybiB1cmwuc2xpY2UoMCwgdXJsLmxlbmd0aCAtIDUpO1xuXHR9XG5cblx0ZnVuY3Rpb24gbWFrZUNvbW1vbkpzKG1pZDogc3RyaW5nKTogRG9qb0xvYWRlci5Nb2R1bGUge1xuXHRcdHJldHVybiAobW9kdWxlc1ttaWRdID0gPERvam9Mb2FkZXIuTW9kdWxlPiA8YW55PiB7XG5cdFx0XHRtaWQ6IG1pZCxcblx0XHRcdGluamVjdGVkOiB0cnVlLFxuXHRcdFx0ZXhlY3V0ZWQ6IHRydWVcblx0XHR9KTtcblx0fVxuXHRjb25zdCBjb21tb25Kc1JlcXVpcmVNb2R1bGU6IERvam9Mb2FkZXIuTW9kdWxlID0gbWFrZUNvbW1vbkpzKCdyZXF1aXJlJyk7XG5cdGNvbnN0IGNvbW1vbkpzRXhwb3J0c01vZHVsZTogRG9qb0xvYWRlci5Nb2R1bGUgPSBtYWtlQ29tbW9uSnMoJ2V4cG9ydHMnKTtcblx0Y29uc3QgY29tbW9uSnNNb2R1bGVNb2R1bGU6IERvam9Mb2FkZXIuTW9kdWxlID0gbWFrZUNvbW1vbkpzKCdtb2R1bGUnKTtcblx0bGV0IGNpcmN1bGFyVHJhY2U6IHN0cmluZ1tdO1xuXG5cdGhhcy5hZGQoJ2xvYWRlci1kZWJ1Zy1jaXJjdWxhci1kZXBlbmRlbmNpZXMnLCB0cnVlKTtcblx0aWYgKGhhcygnbG9hZGVyLWRlYnVnLWNpcmN1bGFyLWRlcGVuZGVuY2llcycpKSB7XG5cdFx0Y2lyY3VsYXJUcmFjZSA9IFtdO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXhlY3V0ZU1vZHVsZShtb2R1bGU6IERvam9Mb2FkZXIuTW9kdWxlKTogYW55IHtcblx0XHQvLyBydW4gdGhlIGRlcGVuZGVuY3kgYXJyYXksIHRoZW4gcnVuIHRoZSBmYWN0b3J5IGZvciBtb2R1bGVcblx0XHRpZiAobW9kdWxlLmV4ZWN1dGVkID09PSBFWEVDVVRJTkcpIHtcblx0XHRcdC8vIGZvciBjaXJjdWxhciBkZXBlbmRlbmNpZXMsIGFzc3VtZSB0aGUgZmlyc3QgbW9kdWxlIGVuY291bnRlcmVkIHdhcyBleGVjdXRlZCBPS1xuXHRcdFx0Ly8gbW9kdWxlcyB0aGF0IGNpcmN1bGFybHkgZGVwZW5kIG9uIGEgbW9kdWxlIHRoYXQgaGFzIG5vdCBydW4gaXRzIGZhY3Rvcnkgd2lsbCBnZXRcblx0XHRcdC8vIHRoZSBwcmVtYWRlIGNqcy5leHBvcnRzPT09bW9kdWxlLnJlc3VsdC4gVGhleSBjYW4gdGFrZSBhIHJlZmVyZW5jZSB0byB0aGlzIG9iamVjdCBhbmQvb3Jcblx0XHRcdC8vIGFkZCBwcm9wZXJ0aWVzIHRvIGl0LiBXaGVuIHRoZSBtb2R1bGUgZmluYWxseSBydW5zIGl0cyBmYWN0b3J5LCB0aGUgZmFjdG9yeSBjYW5cblx0XHRcdC8vIHJlYWQvd3JpdGUvcmVwbGFjZSB0aGlzIG9iamVjdC4gTm90aWNlIHRoYXQgc28gbG9uZyBhcyB0aGUgb2JqZWN0IGlzbid0IHJlcGxhY2VkLCBhbnlcblx0XHRcdC8vIHJlZmVyZW5jZSB0YWtlbiBlYXJsaWVyIHdoaWxlIHdhbGtpbmcgdGhlIGRlcGVuZGVuY2llcyBsaXN0IGlzIHN0aWxsIHZhbGlkLlxuXHRcdFx0aWYgKFxuXHRcdFx0XHRoYXMoJ2xvYWRlci1kZWJ1Zy1jaXJjdWxhci1kZXBlbmRlbmNpZXMnKSAmJlxuXHRcdFx0XHRtb2R1bGUuZGVwcy5pbmRleE9mKGNvbW1vbkpzRXhwb3J0c01vZHVsZSkgPT09IC0xICYmXG5cdFx0XHRcdHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJ1xuXHRcdFx0KSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignQ2lyY3VsYXIgZGVwZW5kZW5jeTogJyArIGNpcmN1bGFyVHJhY2UuY29uY2F0KG1vZHVsZS5taWQpLmpvaW4oJyAtPiAnKSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtb2R1bGUucmVzdWx0O1xuXHRcdH1cblxuXHRcdGlmICghbW9kdWxlLmV4ZWN1dGVkKSB7XG5cdFx0XHQvLyBUT0RPOiBUaGlzIHNlZW1zIGxpa2UgYW4gaW5jb3JyZWN0IGNvbmRpdGlvbiBpbmZlcmVuY2UuIE9yaWdpbmFsbHkgaXQgd2FzIHNpbXBseSAhbW9kdWxlLmRlZlxuXHRcdFx0Ly8gd2hpY2ggY2F1c2VkIG1vZHVsZXMgd2l0aCBmYWxzeSBkZWZpbmVkIHZhbHVlcyB0byBuZXZlciBleGVjdXRlLlxuXHRcdFx0aWYgKCFtb2R1bGUuZGVmICYmICFtb2R1bGUuZGVwcykge1xuXHRcdFx0XHRyZXR1cm4gQUJPUlRfRVhFQ1VUSU9OO1xuXHRcdFx0fVxuXG5cdFx0XHRoYXMoJ2xvYWRlci1kZWJ1Zy1jaXJjdWxhci1kZXBlbmRlbmNpZXMnKSAmJiBjaXJjdWxhclRyYWNlLnB1c2gobW9kdWxlLm1pZCk7XG5cblx0XHRcdGNvbnN0IGRlcGVuZGVuY2llczogRG9qb0xvYWRlci5Nb2R1bGVbXSA9IG1vZHVsZS5kZXBzO1xuXHRcdFx0bGV0IHJlc3VsdDogYW55O1xuXG5cdFx0XHRtb2R1bGUuZXhlY3V0ZWQgPSBFWEVDVVRJTkc7XG5cdFx0XHRsZXQgZXhlY3V0ZWREZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXMubWFwKGZ1bmN0aW9uIChkZXBlbmRlbmN5OiBEb2pvTG9hZGVyLk1vZHVsZSk6IGFueSB7XG5cdFx0XHRcdGlmIChyZXN1bHQgIT09IEFCT1JUX0VYRUNVVElPTikge1xuXHRcdFx0XHRcdC8vIGNoZWNrIGZvciBrZXl3b3JkIGRlcGVuZGVuY2llczogRG9qb0xvYWRlci5yZXF1aXJlLCBleHBvcnRzLCBtb2R1bGU7IHRoZW4gZXhlY3V0ZSBtb2R1bGUgZGVwZW5kZW5jeVxuXHRcdFx0XHRcdHJlc3VsdCA9ICgoZGVwZW5kZW5jeSA9PT0gY29tbW9uSnNSZXF1aXJlTW9kdWxlKSA/IGNyZWF0ZVJlcXVpcmUobW9kdWxlKSA6XG5cdFx0XHRcdFx0XHRcdFx0KChkZXBlbmRlbmN5ID09PSBjb21tb25Kc0V4cG9ydHNNb2R1bGUpID8gbW9kdWxlLmNqcy5leHBvcnRzIDpcblx0XHRcdFx0XHRcdFx0XHRcdCgoZGVwZW5kZW5jeSA9PT0gY29tbW9uSnNNb2R1bGVNb2R1bGUpID8gbW9kdWxlLmNqcyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGV4ZWN1dGVNb2R1bGUoZGVwZW5kZW5jeSkpKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdH0pO1xuXG5cdFx0XHRpZiAocmVzdWx0ID09PSBBQk9SVF9FWEVDVVRJT04pIHtcblx0XHRcdFx0bW9kdWxlLmV4ZWN1dGVkID0gZmFsc2U7XG5cdFx0XHRcdGhhcygnbG9hZGVyLWRlYnVnLWNpcmN1bGFyLWRlcGVuZGVuY2llcycpICYmIGNpcmN1bGFyVHJhY2UucG9wKCk7XG5cdFx0XHRcdHJldHVybiBBQk9SVF9FWEVDVVRJT047XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGZhY3Rvcnk6IERvam9Mb2FkZXIuRmFjdG9yeSA9IG1vZHVsZS5kZWY7XG5cdFx0XHRyZXN1bHQgPSB0eXBlb2YgZmFjdG9yeSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkuYXBwbHkobnVsbCwgZXhlY3V0ZWREZXBlbmRlbmNpZXMpIDogZmFjdG9yeTtcblxuXHRcdFx0Ly8gVE9ETzogQnV0IG9mIGNvdXJzZSwgbW9kdWxlLmNqcyBhbHdheXMgZXhpc3RzLlxuXHRcdFx0Ly8gQXNzaWduIHRoZSBuZXcgbW9kdWxlLnJlc3VsdCB0byByZXN1bHQgc28gcGx1Z2lucyBjYW4gdXNlIGV4cG9ydHNcblx0XHRcdC8vIHRvIGRlZmluZSB0aGVpciBpbnRlcmZhY2U7IHRoZSBwbHVnaW4gY2hlY2tzIGJlbG93IHVzZSByZXN1bHRcblx0XHRcdHJlc3VsdCA9IG1vZHVsZS5yZXN1bHQgPSByZXN1bHQgPT09IHVuZGVmaW5lZCAmJiBtb2R1bGUuY2pzID8gbW9kdWxlLmNqcy5leHBvcnRzIDogcmVzdWx0O1xuXHRcdFx0bW9kdWxlLmV4ZWN1dGVkID0gdHJ1ZTtcblx0XHRcdGV4ZWN1dGVkU29tZXRoaW5nID0gdHJ1ZTtcblxuXHRcdFx0Ly8gZGVsZXRlIHJlZmVyZW5jZXMgdG8gc3ludGhldGljIG1vZHVsZXNcblx0XHRcdGlmIChtb2R1bGUuZ2MpIHtcblx0XHRcdFx0bW9kdWxlc1ttb2R1bGUubWlkXSA9IHVuZGVmaW5lZDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gaWYgcmVzdWx0IGRlZmluZXMgbG9hZCwganVzdCBhc3N1bWUgaXQncyBhIHBsdWdpbjsgaGFybWxlc3MgaWYgdGhlIGFzc3VtcHRpb24gaXMgd3Jvbmdcblx0XHRcdHJlc3VsdCAmJiByZXN1bHQubG9hZCAmJiBbICdub3JtYWxpemUnLCAnbG9hZCcgXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXk6IHN0cmluZyk6IHZvaWQge1xuXHRcdFx0XHQoPGFueT4gbW9kdWxlKVtrZXldID0gKDxhbnk+IHJlc3VsdClba2V5XTtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBmb3IgcGx1Z2lucywgcmVzb2x2ZSB0aGUgbG9hZFFcblx0XHRcdGZvckVhY2gobW9kdWxlLmxvYWRRLCBmdW5jdGlvbiAocHNldWRvUGx1Z2luUmVzb3VyY2U6IERvam9Mb2FkZXIuTW9kdWxlKTogdm9pZCB7XG5cdFx0XHRcdC8vIG1hbnVmYWN0dXJlIGFuZCBpbnNlcnQgdGhlIHJlYWwgbW9kdWxlIGluIG1vZHVsZXNcblx0XHRcdFx0Y29uc3QgcGx1Z2luUmVzb3VyY2VJZDogc3RyaW5nID0gcmVzb2x2ZVBsdWdpblJlc291cmNlSWQobW9kdWxlLCBwc2V1ZG9QbHVnaW5SZXNvdXJjZS5wcmlkLFxuXHRcdFx0XHRcdHBzZXVkb1BsdWdpblJlc291cmNlLnJlcSk7XG5cdFx0XHRcdGNvbnN0IG1vZHVsZUlkOiBzdHJpbmcgPSAobW9kdWxlLm1pZCArICchJyArIHBsdWdpblJlc291cmNlSWQpO1xuXHRcdFx0XHRjb25zdCBwbHVnaW5SZXNvdXJjZTogRG9qb0xvYWRlci5Nb2R1bGUgPVxuXHRcdFx0XHRcdDxEb2pvTG9hZGVyLk1vZHVsZT4gbWl4KG1peCh7fSwgcHNldWRvUGx1Z2luUmVzb3VyY2UpLCB7IG1pZDogbW9kdWxlSWQsIHByaWQ6IHBsdWdpblJlc291cmNlSWQgfSk7XG5cblx0XHRcdFx0aWYgKCFtb2R1bGVzW21vZHVsZUlkXSkge1xuXHRcdFx0XHRcdC8vIGNyZWF0ZSBhIG5ldyAodGhlIHJlYWwpIHBsdWdpbiByZXNvdXJjZSBhbmQgaW5qZWN0IGl0IG5vcm1hbGx5IG5vdyB0aGF0IHRoZSBwbHVnaW4gaXMgb24gYm9hcmRcblx0XHRcdFx0XHRpbmplY3RQbHVnaW4oKG1vZHVsZXNbbW9kdWxlSWRdID0gcGx1Z2luUmVzb3VyY2UpKTtcblx0XHRcdFx0fSAvLyBlbHNlIHRoaXMgd2FzIGEgZHVwbGljYXRlIHJlcXVlc3QgZm9yIHRoZSBzYW1lIChwbHVnaW4sIHJpZClcblxuXHRcdFx0XHQvLyBwbHVnaW5SZXNvdXJjZSBpcyByZWFsbHkganVzdCBhIHBsYWNlaG9sZGVyIHdpdGggdGhlIHdyb25nIG1vZHVsZUlkIChiZWNhdXNlIHdlIGNvdWxkbid0IGNhbGN1bGF0ZSBpdFxuXHRcdFx0XHQvLyB1bnRpbCB0aGUgcGx1Z2luIHdhcyBvbiBib2FyZCkgZml4KCkgcmVwbGFjZXMgdGhlIHBzZXVkbyBtb2R1bGUgaW4gYSByZXNvbHZlZCBkZXBlbmRlbmNpZXMgYXJyYXkgd2l0aCB0aGVcblx0XHRcdFx0Ly8gcmVhbCBtb2R1bGUgbGFzdGx5LCBtYXJrIHRoZSBwc2V1ZG8gbW9kdWxlIGFzIGFycml2ZWQgYW5kIGRlbGV0ZSBpdCBmcm9tIG1vZHVsZXNcblx0XHRcdFx0cHNldWRvUGx1Z2luUmVzb3VyY2UuZml4KG1vZHVsZXNbbW9kdWxlSWRdKTtcblx0XHRcdFx0LS13YWl0aW5nQ291bnQ7XG5cdFx0XHRcdG1vZHVsZXNbcHNldWRvUGx1Z2luUmVzb3VyY2UubWlkXSA9IHVuZGVmaW5lZDtcblx0XHRcdH0pO1xuXHRcdFx0bW9kdWxlLmxvYWRRID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRoYXMoJ2xvYWRlci1kZWJ1Zy1jaXJjdWxhci1kZXBlbmRlbmNpZXMnKSAmJiBjaXJjdWxhclRyYWNlLnBvcCgpO1xuXHRcdH1cblxuXHRcdC8vIGF0IHRoaXMgcG9pbnQgdGhlIG1vZHVsZSBpcyBndWFyYW50ZWVkIGZ1bGx5IGV4ZWN1dGVkXG5cdFx0cmV0dXJuIG1vZHVsZS5yZXN1bHQ7XG5cdH1cblxuXHQvLyBUT0RPOiBGaWd1cmUgb3V0IHdoYXQgcHJvYyBhY3R1YWxseSBpc1xuXHRmdW5jdGlvbiBndWFyZENoZWNrQ29tcGxldGUoY2FsbGJhY2s6IEZ1bmN0aW9uKTogdm9pZCB7XG5cdFx0KytjaGVja0NvbXBsZXRlR3VhcmQ7XG5cdFx0Y2FsbGJhY2soKTtcblx0XHQtLWNoZWNrQ29tcGxldGVHdWFyZDtcblx0fVxuXG5cdGZ1bmN0aW9uIGNoZWNrQ29tcGxldGUoKTogdm9pZCB7XG5cdFx0Ly8ga2VlcCBnb2luZyB0aHJvdWdoIHRoZSBleGVjdXRpb25RdWV1ZSBhcyBsb25nIGFzIGF0IGxlYXN0IG9uZSBmYWN0b3J5IGlzIGV4ZWN1dGVkXG5cdFx0Ly8gcGx1Z2lucywgcmVjdXJzaW9uLCBjYWNoZWQgbW9kdWxlcyBhbGwgbWFrZSBmb3IgbWFueSBleGVjdXRpb24gcGF0aCBwb3NzaWJpbGl0aWVzXG5cdFx0IWNoZWNrQ29tcGxldGVHdWFyZCAmJiBndWFyZENoZWNrQ29tcGxldGUoZnVuY3Rpb24gKCk6IHZvaWQge1xuXHRcdFx0Zm9yIChsZXQgbW9kdWxlOiBEb2pvTG9hZGVyLk1vZHVsZSwgaSA9IDA7IGkgPCBleGVjdXRpb25RdWV1ZS5sZW5ndGg7ICkge1xuXHRcdFx0XHRtb2R1bGUgPSBleGVjdXRpb25RdWV1ZVtpXTtcblx0XHRcdFx0aWYgKG1vZHVsZS5leGVjdXRlZCA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdGV4ZWN1dGlvblF1ZXVlLnNwbGljZShpLCAxKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRleGVjdXRlZFNvbWV0aGluZyA9IGZhbHNlO1xuXHRcdFx0XHRcdGV4ZWN1dGVNb2R1bGUobW9kdWxlKTtcblx0XHRcdFx0XHRpZiAoZXhlY3V0ZWRTb21ldGhpbmcpIHtcblx0XHRcdFx0XHRcdC8vIHNvbWV0aGluZyB3YXMgZXhlY3V0ZWQ7IHRoaXMgaW5kaWNhdGVzIHRoZSBleGVjdXRpb25RdWV1ZSB3YXMgbW9kaWZpZWQsIG1heWJlIGFcblx0XHRcdFx0XHRcdC8vIGxvdCAoZm9yIGV4YW1wbGUgYSBsYXRlciBtb2R1bGUgY2F1c2VzIGFuIGVhcmxpZXIgbW9kdWxlIHRvIGV4ZWN1dGUpXG5cdFx0XHRcdFx0XHRpID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyBub3RoaW5nIGhhcHBlbmVkOyBjaGVjayB0aGUgbmV4dCBtb2R1bGUgaW4gdGhlIGV4ZWMgcXVldWVcblx0XHRcdFx0XHRcdGkrKztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGluamVjdFBsdWdpbihtb2R1bGU6IERvam9Mb2FkZXIuTW9kdWxlKTogdm9pZCB7XG5cdFx0Ly8gaW5qZWN0cyB0aGUgcGx1Z2luIG1vZHVsZSBnaXZlbiBieSBtb2R1bGU7IG1heSBoYXZlIHRvIGluamVjdCB0aGUgcGx1Z2luIGl0c2VsZlxuXHRcdGNvbnN0IHBsdWdpbjogRG9qb0xvYWRlci5Nb2R1bGUgPSBtb2R1bGUucGx1Z2luO1xuXHRcdGNvbnN0IG9uTG9hZCA9IGZ1bmN0aW9uIChkZWY6IGFueSk6IHZvaWQge1xuXHRcdFx0XHRtb2R1bGUucmVzdWx0ID0gZGVmO1xuXHRcdFx0XHQtLXdhaXRpbmdDb3VudDtcblx0XHRcdFx0bW9kdWxlLmV4ZWN1dGVkID0gdHJ1ZTtcblx0XHRcdFx0Y2hlY2tDb21wbGV0ZSgpO1xuXHRcdFx0fTtcblxuXHRcdGlmIChwbHVnaW4ubG9hZCkge1xuXHRcdFx0cGx1Z2luLmxvYWQobW9kdWxlLnByaWQsIG1vZHVsZS5yZXEsIG9uTG9hZCwgY29uZmlnKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAocGx1Z2luLmxvYWRRKSB7XG5cdFx0XHRwbHVnaW4ubG9hZFEucHVzaChtb2R1bGUpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdC8vIHRoZSB1bnNoaWZ0IGluc3RlYWQgb2YgcHVzaCBpcyBpbXBvcnRhbnQ6IHdlIGRvbid0IHdhbnQgcGx1Z2lucyB0byBleGVjdXRlIGFzXG5cdFx0XHQvLyBkZXBlbmRlbmNpZXMgb2Ygc29tZSBvdGhlciBtb2R1bGUgYmVjYXVzZSB0aGlzIG1heSBjYXVzZSBjaXJjbGVzIHdoZW4gdGhlIHBsdWdpblxuXHRcdFx0Ly8gbG9hZFEgaXMgcnVuOyBhbHNvLCBnZW5lcmFsbHksIHdlIHdhbnQgcGx1Z2lucyB0byBydW4gZWFybHkgc2luY2UgdGhleSBtYXkgbG9hZFxuXHRcdFx0Ly8gc2V2ZXJhbCBvdGhlciBtb2R1bGVzIGFuZCB0aGVyZWZvcmUgY2FuIHBvdGVudGlhbGx5IHVuYmxvY2sgbWFueSBtb2R1bGVzXG5cdFx0XHRwbHVnaW4ubG9hZFEgPSBbIG1vZHVsZSBdO1xuXHRcdFx0ZXhlY3V0aW9uUXVldWUudW5zaGlmdChwbHVnaW4pO1xuXHRcdFx0aW5qZWN0TW9kdWxlKG1vZHVsZSwgcGx1Z2luKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBpbmplY3RNb2R1bGUocGFyZW50OiBEb2pvTG9hZGVyLk1vZHVsZSwgbW9kdWxlOiBEb2pvTG9hZGVyLk1vZHVsZSk6IHZvaWQge1xuXHRcdC8vIFRPRE86IFRoaXMgaXMgZm9yIGRlYnVnZ2luZywgd2Ugc2hvdWxkIGJyYWNrZXQgaXRcblx0XHRpZiAoIW1vZHVsZSkge1xuXHRcdFx0bW9kdWxlID0gcGFyZW50O1xuXHRcdFx0cGFyZW50ID0gbnVsbDtcblx0XHR9XG5cblx0XHRpZiAobW9kdWxlLnBsdWdpbikge1xuXHRcdFx0aW5qZWN0UGx1Z2luKG1vZHVsZSk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCFtb2R1bGUuaW5qZWN0ZWQpIHtcblx0XHRcdGxldCBjYWNoZWQ6IERvam9Mb2FkZXIuRmFjdG9yeTtcblx0XHRcdGNvbnN0IG9uTG9hZENhbGxiYWNrID0gZnVuY3Rpb24gKG5vZGU/OiBIVE1MU2NyaXB0RWxlbWVudCk6IHZvaWQge1xuXHRcdFx0XHQvLyBEb2pvTG9hZGVyLm1vZHVsZURlZmluaXRpb25Bcmd1bWVudHMgaXMgYW4gYXJyYXkgb2YgW2RlcGVuZGVuY2llcywgZmFjdG9yeV1cblx0XHRcdFx0Y29uc3VtZVBlbmRpbmdDYWNoZUluc2VydChtb2R1bGUpO1xuXG5cdFx0XHRcdGlmIChoYXMoJ2xvYWRlci1pZTktY29tcGF0JykgJiYgbm9kZSkge1xuXHRcdFx0XHRcdG1vZHVsZURlZmluaXRpb25Bcmd1bWVudHMgPSAoPGFueT4gbm9kZSkuZGVmQXJncztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIG5vbi1hbWQgbW9kdWxlXG5cdFx0XHRcdGlmICghbW9kdWxlRGVmaW5pdGlvbkFyZ3VtZW50cykge1xuXHRcdFx0XHRcdG1vZHVsZURlZmluaXRpb25Bcmd1bWVudHMgPSBbIFtdLCB1bmRlZmluZWQgXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRlZmluZU1vZHVsZShtb2R1bGUsIG1vZHVsZURlZmluaXRpb25Bcmd1bWVudHNbMF0sIG1vZHVsZURlZmluaXRpb25Bcmd1bWVudHNbMV0pO1xuXHRcdFx0XHRtb2R1bGVEZWZpbml0aW9uQXJndW1lbnRzID0gbnVsbDtcblxuXHRcdFx0XHRndWFyZENoZWNrQ29tcGxldGUoZnVuY3Rpb24gKCk6IHZvaWQge1xuXHRcdFx0XHRcdGZvckVhY2gobW9kdWxlLmRlcHMsIGluamVjdE1vZHVsZS5iaW5kKG51bGwsIG1vZHVsZSkpO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0Y2hlY2tDb21wbGV0ZSgpO1xuXHRcdFx0fTtcblxuXHRcdFx0Kyt3YWl0aW5nQ291bnQ7XG5cdFx0XHRtb2R1bGUuaW5qZWN0ZWQgPSB0cnVlO1xuXHRcdFx0aWYgKChjYWNoZWQgPSBjYWNoZVttb2R1bGUubWlkXSkpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRjYWNoZWQoKTtcblx0XHRcdFx0XHRvbkxvYWRDYWxsYmFjaygpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0XHQvLyBJZiBhIGNhY2hlIGxvYWQgZmFpbHMsIHJldHJpZXZlIHVzaW5nIGluamVjdFVybFxuXHRcdFx0XHRcdC8vIFRPRE86IHJlcG9ydCBlcnJvciwgJ2NhY2hlZFRocmV3JywgWyBlcnJvciwgbW9kdWxlIF1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aW5qZWN0VXJsKG1vZHVsZS51cmwsIG9uTG9hZENhbGxiYWNrLCBtb2R1bGUsIHBhcmVudCk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gcmVzb2x2ZURlcGVuZGVuY2llcyhkZXBlbmRlbmNpZXM6IHN0cmluZ1tdLCBtb2R1bGU6IERvam9Mb2FkZXIuTW9kdWxlLCByZWZlcmVuY2VNb2R1bGU6IERvam9Mb2FkZXIuTW9kdWxlKTogRG9qb0xvYWRlci5Nb2R1bGVbXSB7XG5cdFx0Ly8gcmVzb2x2ZSBkZXBlbmRlbmNpZXMgd2l0aCByZXNwZWN0IHRvIHRoaXMgbW9kdWxlXG5cdFx0cmV0dXJuIGRlcGVuZGVuY2llcy5tYXAoZnVuY3Rpb24gKGRlcGVuZGVuY3k6IHN0cmluZywgaTogbnVtYmVyKTogRG9qb0xvYWRlci5Nb2R1bGUge1xuXHRcdFx0Y29uc3QgcmVzdWx0OiBEb2pvTG9hZGVyLk1vZHVsZSA9IGdldE1vZHVsZShkZXBlbmRlbmN5LCByZWZlcmVuY2VNb2R1bGUpO1xuXHRcdFx0aWYgKHJlc3VsdC5maXgpIHtcblx0XHRcdFx0cmVzdWx0LmZpeCA9IGZ1bmN0aW9uIChtOiBEb2pvTG9hZGVyLk1vZHVsZSk6IHZvaWQge1xuXHRcdFx0XHRcdG1vZHVsZS5kZXBzW2ldID0gbTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fSk7XG5cdH1cblxuXHRmdW5jdGlvbiBkZWZpbmVNb2R1bGUobW9kdWxlOiBEb2pvTG9hZGVyLk1vZHVsZSwgZGVwZW5kZW5jaWVzOiBzdHJpbmdbXSwgZmFjdG9yeTogRG9qb0xvYWRlci5GYWN0b3J5KTogRG9qb0xvYWRlci5Nb2R1bGUge1xuXHRcdC0td2FpdGluZ0NvdW50O1xuXHRcdHJldHVybiBpbml0aWFsaXplTW9kdWxlKG1vZHVsZSwgZGVwZW5kZW5jaWVzLCBmYWN0b3J5KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGluaXRpYWxpemVNb2R1bGUobW9kdWxlOiBEb2pvTG9hZGVyLk1vZHVsZSwgZGVwZW5kZW5jaWVzOiBzdHJpbmdbXSwgZmFjdG9yeTogRG9qb0xvYWRlci5GYWN0b3J5KTogRG9qb0xvYWRlci5Nb2R1bGUge1xuXHRcdHJldHVybiA8RG9qb0xvYWRlci5Nb2R1bGU+IG1peChtb2R1bGUsIHtcblx0XHRcdGRlZjogZmFjdG9yeSxcblx0XHRcdGRlcHM6IHJlc29sdmVEZXBlbmRlbmNpZXMoZGVwZW5kZW5jaWVzLCBtb2R1bGUsIG1vZHVsZSksXG5cdFx0XHRjanM6IHtcblx0XHRcdFx0aWQ6IG1vZHVsZS5taWQsXG5cdFx0XHRcdHVyaTogbW9kdWxlLnVybCxcblx0XHRcdFx0ZXhwb3J0czogKG1vZHVsZS5yZXN1bHQgPSB7fSksXG5cdFx0XHRcdHNldEV4cG9ydHM6IGZ1bmN0aW9uIChleHBvcnRzOiBhbnkpOiB2b2lkIHtcblx0XHRcdFx0XHRtb2R1bGUuY2pzLmV4cG9ydHMgPSBleHBvcnRzO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHRoYXMuYWRkKCdmdW5jdGlvbi1iaW5kJywgQm9vbGVhbihGdW5jdGlvbi5wcm90b3R5cGUuYmluZCkpO1xuXHRpZiAoIWhhcygnZnVuY3Rpb24tYmluZCcpKSB7XG5cdFx0aW5qZWN0TW9kdWxlLmJpbmQgPSBmdW5jdGlvbiAodGhpc0FyZzogYW55KTogdHlwZW9mIGluamVjdE1vZHVsZSB7XG5cdFx0XHRjb25zdCBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblx0XHRcdGNvbnN0IGFyZ3M6IGFueVtdID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCk6IHZvaWQge1xuXHRcdFx0XHRyZXR1cm4gaW5qZWN0TW9kdWxlLmFwcGx5KHRoaXNBcmcsIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSkpO1xuXHRcdFx0fTtcblx0XHR9O1xuXHR9XG5cblx0bGV0IGdsb2JhbE9iamVjdEdsb2JhbHMgPSBmdW5jdGlvbiAocmVxdWlyZTogRG9qb0xvYWRlci5SZXF1aXJlLCBkZWZpbmU6IERvam9Mb2FkZXIuRGVmaW5lKTogdm9pZCB7XG5cdFx0Z2xvYmFsT2JqZWN0LnJlcXVpcmUgPSByZXF1aXJlO1xuXHRcdGdsb2JhbE9iamVjdC5kZWZpbmUgPSBkZWZpbmU7XG5cdH07XG5cblx0aWYgKGhhcygnaG9zdC1ub2RlJykpIHtcblx0XHRsb2FkTm9kZU1vZHVsZSA9IChtb2R1bGVJZDogc3RyaW5nLCBwYXJlbnQ/OiBEb2pvTG9hZGVyLk1vZHVsZSk6IGFueSA9PiB7XG5cdFx0XHRsZXQgbW9kdWxlOiBhbnkgPSByZXF1aXJlKCdtb2R1bGUnKTtcblx0XHRcdGxldCByZXN1bHQ6IGFueTtcblxuXHRcdFx0aWYgKG1vZHVsZS5fZmluZFBhdGggJiYgbW9kdWxlLl9ub2RlTW9kdWxlUGF0aHMpIHtcblx0XHRcdFx0bGV0IGxvY2FsTW9kdWxlUGF0aCA9IG1vZHVsZS5fZmluZFBhdGgobW9kdWxlSWQsIG1vZHVsZS5fbm9kZU1vZHVsZVBhdGhzKHRvVXJsKCcuJywgcGFyZW50KSkpO1xuXG5cdFx0XHRcdGlmIChsb2NhbE1vZHVsZVBhdGggIT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0bW9kdWxlSWQgPSBsb2NhbE1vZHVsZVBhdGg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU29tZSBtb2R1bGVzIGF0dGVtcHQgdG8gZGV0ZWN0IGFuIEFNRCBsb2FkZXIgYnkgbG9va2luZyBmb3IgZ2xvYmFsIEFNRCBgZGVmaW5lYC4gVGhpcyBjYXVzZXMgaXNzdWVzXG5cdFx0XHQvLyB3aGVuIG90aGVyIENvbW1vbkpTIG1vZHVsZXMgYXR0ZW1wdCB0byBsb2FkIHRoZW0gdmlhIHRoZSBzdGFuZGFyZCBOb2RlLmpzIGByZXF1aXJlYCwgc28gaGlkZSBpdFxuXHRcdFx0Ly8gZHVyaW5nIHRoZSBsb2FkXG5cdFx0XHRnbG9iYWxPYmplY3QuZGVmaW5lID0gdW5kZWZpbmVkO1xuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRyZXN1bHQgPSByZXF1aXJlTW9kdWxlLm5vZGVSZXF1aXJlKG1vZHVsZUlkKTtcblx0XHRcdH1cblx0XHRcdGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHQvLyBJZiB0aGUgTm9kZS5qcyAncmVxdWlyZScgZnVuY3Rpb24gY2Fubm90IGxvY2F0ZSBhIG1vZHVsZSBpdCB3aWxsIHRocm93IFwiRXJyb3I6IENhbm5vdCBmaW5kIG1vZHVsZVwiXG5cdFx0XHRcdC8vIExlYXZlIGl0IHRvIHRoZSBjYWxsZXIgb2YgdGhpcyBmdW5jdGlvbiB0byBoYW5kbGUgYSBub24tZXhpc3RlbnQgbW9kdWxlXG5cdFx0XHRcdC8vIChhbmQgdGhyb3cgYW4gZXJyb3IgaWYgZGVzaXJlZClcblx0XHRcdFx0cmVzdWx0ID0gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdFx0ZmluYWxseSB7XG5cdFx0XHRcdGdsb2JhbE9iamVjdC5kZWZpbmUgPSBkZWZpbmU7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fTtcblxuXHRcdGNvbnN0IHZtOiBhbnkgPSByZXF1aXJlKCd2bScpO1xuXHRcdGNvbnN0IGZzOiBhbnkgPSByZXF1aXJlKCdmcycpO1xuXG5cdFx0Ly8gcmV0YWluIHRoZSBhYmlsaXR5IHRvIGdldCBub2RlJ3MgcmVxdWlyZVxuXHRcdHJlcXVpcmVNb2R1bGUubm9kZVJlcXVpcmUgPSByZXF1aXJlO1xuXHRcdGluamVjdFVybCA9IGZ1bmN0aW9uICh1cmw6IHN0cmluZywgY2FsbGJhY2s6IChub2RlPzogSFRNTFNjcmlwdEVsZW1lbnQpID0+IHZvaWQsXG5cdFx0XHRcdFx0XHRcdG1vZHVsZTogRG9qb0xvYWRlci5Nb2R1bGUsIHBhcmVudD86IERvam9Mb2FkZXIuTW9kdWxlKTogdm9pZCB7XG5cdFx0XHRmcy5yZWFkRmlsZSh1cmwsICd1dGY4JywgZnVuY3Rpb24gKGVycm9yOiBFcnJvciwgZGF0YTogc3RyaW5nKTogdm9pZCB7XG5cdFx0XHRcdGZ1bmN0aW9uIGxvYWRDYWxsYmFjayAoKSB7XG5cdFx0XHRcdFx0bGV0IHJlc3VsdCA9IGxvYWROb2RlTW9kdWxlKG1vZHVsZS5taWQsIHBhcmVudCk7XG5cblx0XHRcdFx0XHRcdGlmICghcmVzdWx0KSB7XG5cdFx0XHRcdFx0XHRcdHJlcG9ydE1vZHVsZUxvYWRFcnJvcihwYXJlbnQsIG1vZHVsZSwgdXJsKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGVycm9yKSB7XG5cdFx0XHRcdFx0bW9kdWxlRGVmaW5pdGlvbkFyZ3VtZW50cyA9IFsgW10sIGxvYWRDYWxsYmFjayBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdC8vIGdsb2JhbCBgbW9kdWxlYCB2YXJpYWJsZSBuZWVkcyB0byBiZSBzaGFkb3dlZCBmb3IgVU1EIG1vZHVsZXMgdGhhdCBhcmUgbG9hZGVkIGluIGFuIEVsZWN0cm9uXG5cdFx0XHRcdFx0Ly8gd2VidmlldzsgaW4gTm9kZS5qcyB0aGUgYG1vZHVsZWAgdmFyaWFibGUgZG9lcyBub3QgZXhpc3Qgd2hlbiB1c2luZyBgdm0ucnVuSW5UaGlzQ29udGV4dGAsXG5cdFx0XHRcdFx0Ly8gYnV0IGluIEVsZWN0cm9uIGl0IGV4aXN0cyBpbiB0aGUgd2VidmlldyB3aGVuIE5vZGUuanMgaW50ZWdyYXRpb24gaXMgZW5hYmxlZCB3aGljaCBjYXVzZXMgbG9hZGVkXG5cdFx0XHRcdFx0Ly8gbW9kdWxlcyB0byByZWdpc3RlciB3aXRoIE5vZGUuanMgYW5kIGJyZWFrIHRoZSBsb2FkZXJcblx0XHRcdFx0XHRsZXQgb2xkTW9kdWxlID0gZ2xvYmFsT2JqZWN0Lm1vZHVsZTtcblx0XHRcdFx0XHRnbG9iYWxPYmplY3QubW9kdWxlID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHQvKipcblx0XHRcdFx0XHRcdCAqIFVzaW5nIGFuIGBvYmplY3RgIGFzIGEgc2Vjb25kIGFyZ3VtZW50IGNhdXNlcyBJbnN0YWJ1bFxuXHRcdFx0XHRcdFx0ICogaXNzdWVzIGFuZCB0aGVuIHRoaW5rcyB0aGUgZmlsZSBzaG91bGQgbm90IGJlIGluc3RydW1lbnRlZFxuXHRcdFx0XHRcdFx0ICpcblx0XHRcdFx0XHRcdCAqIFNlZTogZG9qby9sb2FkZXIjNTdcblx0XHRcdFx0XHRcdCAqL1xuXHRcdFx0XHRcdFx0dm0ucnVuSW5UaGlzQ29udGV4dChkYXRhLCB1cmwpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRmaW5hbGx5IHtcblx0XHRcdFx0XHRcdGdsb2JhbE9iamVjdC5tb2R1bGUgPSBvbGRNb2R1bGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdH0pO1xuXHRcdH07XG5cblx0XHRzZXRHbG9iYWxzID0gZnVuY3Rpb24gKHJlcXVpcmU6IERvam9Mb2FkZXIuUm9vdFJlcXVpcmUsIGRlZmluZTogRG9qb0xvYWRlci5EZWZpbmUpOiB2b2lkIHtcblx0XHRcdG1vZHVsZS5leHBvcnRzID0gZ2xvYmFsT2JqZWN0LnJlcXVpcmUgPSByZXF1aXJlO1xuXHRcdFx0Z2xvYmFsT2JqZWN0LmRlZmluZSA9IGRlZmluZTtcblx0XHR9O1xuXHR9XG5cdGVsc2UgaWYgKGhhcygnaG9zdC1icm93c2VyJykpIHtcblx0XHRpbmplY3RVcmwgPSBmdW5jdGlvbiAodXJsOiBzdHJpbmcsIGNhbGxiYWNrOiAobm9kZT86IEhUTUxTY3JpcHRFbGVtZW50KSA9PiB2b2lkLCBtb2R1bGU6IERvam9Mb2FkZXIuTW9kdWxlLFxuXHRcdFx0XHRcdFx0XHRwYXJlbnQ/OiBEb2pvTG9hZGVyLk1vZHVsZSk6IHZvaWQge1xuXHRcdFx0Ly8gaW5zZXJ0IGEgc2NyaXB0IGVsZW1lbnQgdG8gdGhlIGluc2VydC1wb2ludCBlbGVtZW50IHdpdGggc3JjPXVybDtcblx0XHRcdC8vIGFwcGx5IGNhbGxiYWNrIHVwb24gZGV0ZWN0aW5nIHRoZSBzY3JpcHQgaGFzIGxvYWRlZC5cblx0XHRcdGNvbnN0IG5vZGU6IEhUTUxTY3JpcHRFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG5cdFx0XHRjb25zdCBoYW5kbGVyOiBFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50OiBFdmVudCk6IHZvaWQge1xuXHRcdFx0XHRkb2N1bWVudC5oZWFkLnJlbW92ZUNoaWxkKG5vZGUpO1xuXG5cdFx0XHRcdGlmIChldmVudC50eXBlID09PSAnbG9hZCcpIHtcblx0XHRcdFx0XHRoYXMoJ2xvYWRlci1pZTktY29tcGF0JykgPyBjYWxsYmFjayhub2RlKSA6IGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0cmVwb3J0TW9kdWxlTG9hZEVycm9yKHBhcmVudCwgbW9kdWxlLCB1cmwpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBoYW5kbGVyLCBmYWxzZSk7XG5cdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgaGFuZGxlciwgZmFsc2UpO1xuXG5cdFx0XHQoPGFueT4gbm9kZSkuY3Jvc3NPcmlnaW4gPSAnYW5vbnltb3VzJztcblx0XHRcdG5vZGUuY2hhcnNldCA9ICd1dGYtOCc7XG5cdFx0XHRub2RlLnNyYyA9IHVybDtcblx0XHRcdGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQobm9kZSk7XG5cdFx0fTtcblxuXHRcdHNldEdsb2JhbHMgPSBnbG9iYWxPYmplY3RHbG9iYWxzO1xuXHR9XG5cdGVsc2UgaWYgKGhhcygnaG9zdC1uYXNob3JuJykpIHtcblx0XHRpbmplY3RVcmwgPSBmdW5jdGlvbiAodXJsOiBzdHJpbmcsIGNhbGxiYWNrOiAobm9kZT86IEhUTUxTY3JpcHRFbGVtZW50KSA9PiB2b2lkLCBtb2R1bGU6IERvam9Mb2FkZXIuTW9kdWxlLFxuXHRcdFx0cGFyZW50PzogRG9qb0xvYWRlci5Nb2R1bGUpOiB2b2lkIHtcblxuXHRcdFx0bG9hZCh1cmwpO1xuXHRcdFx0Y2FsbGJhY2soKTtcblx0XHR9O1xuXG5cdFx0c2V0R2xvYmFscyA9IGdsb2JhbE9iamVjdEdsb2JhbHM7XG5cdH1cblx0ZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBwbGF0Zm9ybScpO1xuXHR9XG5cblx0aGFzLmFkZCgnbG9hZGVyLWRlYnVnLWludGVybmFscycsIHRydWUpO1xuXHRpZiAoaGFzKCdsb2FkZXItZGVidWctaW50ZXJuYWxzJykpIHtcblx0XHRyZXF1aXJlTW9kdWxlLmluc3BlY3QgPSBmdW5jdGlvbiAobmFtZTogc3RyaW5nKTogYW55IHtcblx0XHRcdC8qIHRzbGludDpkaXNhYmxlOm5vLWV2YWwgKi9cblx0XHRcdC8vIFRPRE86IFNob3VsZCB0aGlzIHVzZSBjb25zb2xlLmxvZyBzbyBwZW9wbGUgZG8gbm90IGdldCBhbnkgYnJpZ2h0IGlkZWFzIGFib3V0IHVzaW5nIHRoaXMgaW4gYXBwcz9cblx0XHRcdHJldHVybiBldmFsKG5hbWUpO1xuXHRcdFx0LyogdHNsaW50OmVuYWJsZTpuby1ldmFsICovXG5cdFx0fTtcblx0fVxuXG5cdGhhcy5hZGQoJ2xvYWRlci11bmRlZicsIHRydWUpO1xuXHRpZiAoaGFzKCdsb2FkZXItdW5kZWYnKSkge1xuXHRcdHJlcXVpcmVNb2R1bGUudW5kZWYgPSBmdW5jdGlvbiAoaWQ6IHN0cmluZyk6IHZvaWQge1xuXHRcdFx0aWYgKG1vZHVsZXNbaWRdKSB7XG5cdFx0XHRcdG1vZHVsZXNbaWRdID0gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHRtaXgocmVxdWlyZU1vZHVsZSwge1xuXHRcdHRvQWJzTWlkOiB0b0Fic01pZCxcblx0XHR0b1VybDogdG9VcmwsXG5cblx0XHRjYWNoZTogZnVuY3Rpb24gKGNhY2hlOiBEb2pvTG9hZGVyLk9iamVjdE1hcCk6IHZvaWQge1xuXHRcdFx0Y29uc3VtZVBlbmRpbmdDYWNoZUluc2VydCgpO1xuXHRcdFx0cGVuZGluZ0NhY2hlSW5zZXJ0ID0gY2FjaGU7XG5cdFx0fVxuXHR9KTtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkocmVxdWlyZU1vZHVsZSwgJ2Jhc2VVcmwnLCB7XG5cdFx0Z2V0OiBmdW5jdGlvbiAoKTogc3RyaW5nIHtcblx0XHRcdHJldHVybiBjb25maWcuYmFzZVVybDtcblx0XHR9LFxuXHRcdGVudW1lcmFibGU6IHRydWVcblx0fSk7XG5cblx0aGFzLmFkZCgnbG9hZGVyLWNqcy13cmFwcGluZycsIHRydWUpO1xuXG5cdGxldCBjb21tZW50czogUmVnRXhwO1xuXHRsZXQgcmVxdWlyZUNhbGw6IFJlZ0V4cDtcblxuXHRpZiAoaGFzKCdsb2FkZXItY2pzLXdyYXBwaW5nJykpIHtcblx0XHRjb21tZW50cyA9IC9cXC9cXCpbXFxzXFxTXSo/XFwqXFwvfFxcL1xcLy4qJC9tZztcblx0XHRyZXF1aXJlQ2FsbCA9IC9yZXF1aXJlXFxzKlxcKFxccyooW1wiJ10pKC4qP1teXFxcXF0pXFwxXFxzKlxcKS9nO1xuXHR9XG5cblx0aGFzLmFkZCgnbG9hZGVyLWV4cGxpY2l0LW1pZCcsIHRydWUpO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0gZGVwcyAvLyhhcnJheSBvZiBjb21tb25qcy5tb2R1bGVJZCwgb3B0aW9uYWwpXG5cdCAqIEBwYXJhbSBmYWN0b3J5IC8vKGFueSlcblx0ICovXG5cdGxldCBkZWZpbmU6IERvam9Mb2FkZXIuRGVmaW5lID0gPERvam9Mb2FkZXIuRGVmaW5lPiBtaXgoZnVuY3Rpb24gKGRlcGVuZGVuY2llczogc3RyaW5nW10sIGZhY3Rvcnk6IERvam9Mb2FkZXIuRmFjdG9yeSk6IHZvaWQge1xuXHRcdGxldCBvcmlnaW5hbEZhY3Rvcnk6IGFueTtcblx0XHRpZiAoaGFzKCdsb2FkZXItZXhwbGljaXQtbWlkJykgJiYgYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgdHlwZW9mIGRlcGVuZGVuY2llcyA9PT0gJ3N0cmluZycpIHtcblx0XHRcdGxldCBpZDogc3RyaW5nID0gPGFueT4gZGVwZW5kZW5jaWVzO1xuXHRcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcblx0XHRcdFx0ZGVwZW5kZW5jaWVzID0gPGFueT4gZmFjdG9yeTtcblx0XHRcdFx0ZmFjdG9yeSA9IGFyZ3VtZW50c1syXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlcGVuZGVuY2llcyA9IFtdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTb21lIG1vZHVsZXMgaW4gdGhlIHdpbGQgaGF2ZSBhbiBleHBsaWNpdCBtb2R1bGUgSUQgdGhhdCBpcyBudWxsOyBpZ25vcmUgdGhlIG1vZHVsZSBJRCBpbiB0aGlzIGNhc2UgYW5kXG5cdFx0XHQvLyByZWdpc3RlciBub3JtYWxseSB1c2luZyB0aGUgcmVxdWVzdCBtb2R1bGUgSURcblx0XHRcdGlmIChpZCAhPSBudWxsKSB7XG5cdFx0XHRcdGxldCBtb2R1bGU6IERvam9Mb2FkZXIuTW9kdWxlID0gZ2V0TW9kdWxlKGlkKTtcblx0XHRcdFx0aWYgKGZhY3RvcnkpIHtcblx0XHRcdFx0XHRvcmlnaW5hbEZhY3RvcnkgPSBmYWN0b3J5O1xuXHRcdFx0XHRcdGZhY3RvcnkgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRtb2R1bGUuZXhlY3V0ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0cmV0dXJuIChtb2R1bGUucmVzdWx0ID0gb3JpZ2luYWxGYWN0b3J5LmFwcGx5ID9cblx0XHRcdFx0XHRcdFx0b3JpZ2luYWxGYWN0b3J5LmFwcGx5KG51bGwsIGFyZ3VtZW50cykgOiBvcmlnaW5hbEZhY3RvcnkpO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdFx0bW9kdWxlLmluamVjdGVkID0gdHJ1ZTtcblx0XHRcdFx0ZGVmaW5lTW9kdWxlKG1vZHVsZSwgZGVwZW5kZW5jaWVzLCBmYWN0b3J5KTtcblx0XHRcdFx0Z3VhcmRDaGVja0NvbXBsZXRlKGZ1bmN0aW9uICgpOiB2b2lkIHtcblx0XHRcdFx0XHRmb3JFYWNoKG1vZHVsZS5kZXBzLCBpbmplY3RNb2R1bGUuYmluZChudWxsLCBtb2R1bGUpKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcblx0XHRcdGlmIChoYXMoJ2xvYWRlci1janMtd3JhcHBpbmcnKSAmJiB0eXBlb2YgZGVwZW5kZW5jaWVzID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdG9yaWdpbmFsRmFjdG9yeSA9IDxhbnk+IGRlcGVuZGVuY2llcztcblx0XHRcdFx0ZGVwZW5kZW5jaWVzID0gWyAncmVxdWlyZScsICdleHBvcnRzJywgJ21vZHVsZScgXTtcblxuXHRcdFx0XHQvLyBTY2FuIGZhY3RvcnkgZm9yIHJlcXVpcmUoKSBjYWxscyBhbmQgYWRkIHRoZW0gdG8gdGhlXG5cdFx0XHRcdC8vIGxpc3Qgb2YgZGVwZW5kZW5jaWVzXG5cdFx0XHRcdG9yaWdpbmFsRmFjdG9yeS50b1N0cmluZygpXG5cdFx0XHRcdFx0LnJlcGxhY2UoY29tbWVudHMsICcnKVxuXHRcdFx0XHRcdC5yZXBsYWNlKHJlcXVpcmVDYWxsLCBmdW5jdGlvbiAoKTogc3RyaW5nIHtcblx0XHRcdFx0XHRcdGRlcGVuZGVuY2llcy5wdXNoKC8qIG1pZCAqLyBhcmd1bWVudHNbMl0pO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGFyZ3VtZW50c1swXTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0ZmFjdG9yeSA9IGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpOiBhbnkge1xuXHRcdFx0XHRcdGNvbnN0IG9yaWdpbmFsTW9kdWxlSWQgPSBtb2R1bGUuaWQ7XG5cdFx0XHRcdFx0bGV0IHJlc3VsdDogYW55ID0gb3JpZ2luYWxGYWN0b3J5LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdFx0aWYgKG9yaWdpbmFsTW9kdWxlSWQgIT09IG1vZHVsZS5pZCkge1xuXHRcdFx0XHRcdFx0Y29uc3QgbmV3TW9kdWxlOiBEb2pvTG9hZGVyLk1vZHVsZSA9IGdldE1vZHVsZShtb2R1bGUuaWQpO1xuXHRcdFx0XHRcdFx0ZGVmaW5lTW9kdWxlKG5ld01vZHVsZSwgZGVwZW5kZW5jaWVzLCBudWxsKTtcblx0XHRcdFx0XHRcdG5ld01vZHVsZS5pbmplY3RlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRuZXdNb2R1bGUuZXhlY3V0ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0bmV3TW9kdWxlLnJlc3VsdCA9IG1vZHVsZS5leHBvcnRzID0gcmVzdWx0IHx8IG1vZHVsZS5leHBvcnRzO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoLyogZGVmaW5lKHZhbHVlKSAqLyAhQXJyYXkuaXNBcnJheShkZXBlbmRlbmNpZXMpKSB7XG5cdFx0XHRcdGNvbnN0IHZhbHVlOiBhbnkgPSBkZXBlbmRlbmNpZXM7XG5cdFx0XHRcdGRlcGVuZGVuY2llcyA9IFtdO1xuXHRcdFx0XHRmYWN0b3J5ID0gZnVuY3Rpb24gKCk6IGFueSB7XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChoYXMoJ2xvYWRlci1pZTktY29tcGF0JykpIHtcblx0XHRcdGZvciAobGV0IGkgPSBkb2N1bWVudC5zY3JpcHRzLmxlbmd0aCAtIDEsIHNjcmlwdDogSFRNTFNjcmlwdEVsZW1lbnQ7XG5cdFx0XHRcdHNjcmlwdCA9IDxIVE1MU2NyaXB0RWxlbWVudD4gZG9jdW1lbnQuc2NyaXB0c1tpXTtcblx0XHRcdFx0LS1pKSB7XG5cdFx0XHRcdGlmICgoPGFueT4gc2NyaXB0KS5yZWFkeVN0YXRlID09PSAnaW50ZXJhY3RpdmUnKSB7XG5cdFx0XHRcdFx0KDxhbnk+IHNjcmlwdCkuZGVmQXJncyA9IFsgZGVwZW5kZW5jaWVzLCBmYWN0b3J5IF07XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRtb2R1bGVEZWZpbml0aW9uQXJndW1lbnRzID0gWyBkZXBlbmRlbmNpZXMsIGZhY3RvcnkgXTtcblx0XHR9XG5cdH0sIHtcblx0XHRhbWQ6IHsgdmVuZG9yOiAnZG9qb3Rvb2xraXQub3JnJyB9XG5cdH0pO1xuXG5cdHNldEdsb2JhbHMocmVxdWlyZU1vZHVsZSwgZGVmaW5lKTtcblx0aWYgKGhhcygnaG9zdC1uYXNob3JuJykgJiYgYXJnc1swXSkge1xuXHRcdGxvYWQoYXJnc1swXSk7XG5cdH1cbn0pKCh0eXBlb2YgUGFja2FnZXMgIT09ICd1bmRlZmluZWQnID8gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSA6IFtdKSk7XG4iXX0=