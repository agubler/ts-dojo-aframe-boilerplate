import ReadableStream from './ReadableStream';
export declare function isReadableStreamController(x: any): boolean;
export default class ReadableStreamController<T> {
    private _controlledReadableStream;
    /**
     * Returns a number indicating how much additional data can be pushed by the source to the stream's queue before it
     * exceeds its `highWaterMark`. An underlying source should use this information to determine when and how to apply
     * backpressure.
     *
     * @returns The stream's strategy's `highWaterMark` value minus the queue size
     */
    readonly desiredSize: number;
    constructor(stream: ReadableStream<T>);
    /**
     * A source should call this method when it has no more data to provide. After this method is called, the stream
     * will provided any queued data to the reader, but once the stream's queue is exhausted the stream will be closed
     * and no more data can be read from it.
     */
    close(): void;
    /**
     * A source should call this method to provide data to the stream.
     *
     * @param chunk The data to provide to the stream
     */
    enqueue(chunk: T): void;
    /**
     * A source should call this method to indicate an error condition to the stream that irreparably disrupts the
     * source's (and thus the stream's) ability to provide all the intended data.
     *
     * @param error An error object representing the error condition in the source
     */
    error(error: Error): void;
}
