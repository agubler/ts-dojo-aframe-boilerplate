import Promise from 'dojo-shim/Promise';
import { Strategy } from './interfaces';
import SizeQueue from './SizeQueue';
export interface Record<T> {
    close?: boolean;
    chunk?: T;
    reject?: (error: Error) => void;
    resolve?: () => void;
}
/**
 * WritableStream's possible states
 */
export declare enum State {
    Closed = 0,
    Closing = 1,
    Errored = 2,
    Waiting = 3,
    Writable = 4,
}
/**
 * The Sink interface defines the methods a module can implement to create a target sink for a `WritableStream`.
 *
 * The Stream API provides a consistent stream API while `ReadableStream.Source` and `WritableStream.Sink` implementors
 * provide the logic to connect a stream to specific data sources & sinks.
 */
export interface Sink<T> {
    /**
     * Indicates the stream is prematurely closing due to an error.  The sink should do any necessary cleanup
     * and release resources. When a stream calls `abort` it will discard any queued chunks. If the sink does not
     * provide an `abort` method then the stream will call `close` instead.
     *
     * @param reason The reason the stream is closing.
     */
    abort?(reason?: any): Promise<void>;
    /**
     * Indicates the stream is closing.  The sink should do any necessary cleanup and release resources. The stream
     * will not call this method until is has successfully written all queued chunks.
     */
    close?(): Promise<void>;
    /**
     * Requests the sink to prepare for receiving chunks.
     *
     * @param error An error callback that can be used at any time by the sink to indicate an error has occurred.
     * @returns A promise that resolves when the sink's start operation has finished.  If the promise rejects,
     * 		the stream will be errored.
     */
    start?(error: (error: Error) => void): Promise<void>;
    /**
     * Requests the sink write a chunk.
     *
     * @param chunk The chunk to be written.
     * @returns A promise that resolves when the sink's write operation has finished.  If the promise rejects,
     * 		the stream will be errored.
     */
    write?(chunk: T): Promise<void>;
}
/**
 * This class provides a writable stream implementation. Data written to a stream will be passed on to the underlying
 * sink (`WritableStream.Sink`), an instance of which must be supplied to the stream upon instantation. This class
 * provides the standard stream API, while implementations of the `Sink` API allow the data to be written to
 * various persistence layers.
 */
export default class WritableStream<T> {
    /**
     * @returns A promise that is resolved when the stream is closed, or is rejected if the stream errors.
     */
    readonly closed: Promise<void>;
    /**
     * @returns A promise that is resolved when the stream transitions away from the 'waiting' state. The stream will
     * use this to indicate backpressure - an unresolved `ready` promise indicates that writes should not yet be
     * performed.
     */
    readonly ready: Promise<void>;
    /**
     * @returns The stream's current @State
     */
    readonly state: State;
    protected _advancing: boolean;
    protected _closedPromise: Promise<void>;
    protected _readyPromise: Promise<void>;
    protected _rejectClosedPromise: (error: Error) => void;
    protected _rejectReadyPromise: (error: Error) => void;
    protected _resolveClosedPromise: () => void;
    protected _resolveReadyPromise: () => void;
    protected _started: boolean;
    protected _startedPromise: Promise<any> | undefined;
    protected _state: State;
    protected _storedError: Error;
    protected _strategy: Strategy<T>;
    protected _underlyingSink: Sink<T> | undefined;
    protected _queue: SizeQueue<Record<T>>;
    protected _writing: boolean;
    constructor(underlyingSink?: Sink<T>, strategy?: Strategy<T>);
    protected _advanceQueue(): void;
    protected _close(): void;
    protected _error(error: Error): void;
    protected _syncStateWithQueue(): void;
    /**
     * Signals that the producer can no longer write to the stream and it should be immediately moved to an "errored"
     * state. Any un-written data that is queued will be discarded.
     */
    abort(reason: any): Promise<void>;
    /**
     * Signals that the producer is done writing to the stream and wishes to move it to a "closed" state. The stream
     * may have un-writted data queued; until the data has been written the stream will remain in the "closing" state.
     */
    close(): Promise<void>;
    /**
     * Enqueue a chunk of data to be written to the underlying sink. `write` can be called successively without waiting
     * for the previous write's promise to resolve. To respect the stream's backpressure indicator, check if the stream
     * has entered the "waiting" state between writes.
     *
     * @returns A promise that will be fulfilled when the chunk has been written to the underlying sink.
     */
    write(chunk: T): Promise<void>;
}
