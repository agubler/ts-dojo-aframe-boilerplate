import Promise from 'dojo-shim/Promise';
import { Strategy } from './interfaces';
import ReadableStreamController from './ReadableStreamController';
import ReadableStreamReader from './ReadableStreamReader';
import SizeQueue from './SizeQueue';
import TransformStream from './TransformStream';
import WritableStream from './WritableStream';
/**
 * Options used when piping a readable stream to a writable stream.
 */
export interface PipeOptions {
    /**
     * Prevents the writable stream from erroring if the readable stream encounters an error.
     */
    preventAbort?: boolean;
    /**
     *  Prevents the readable stream from erroring if the writable stream encounters an error.
     */
    preventCancel?: boolean;
    /**
     * Prevents the writable stream from closing when the pipe operation completes.
     */
    preventClose?: boolean;
}
/**
 * The Source interface defines the methods a module can implement to create a source for a {@link ReadableStream}.
 *
 * The Stream API provides a consistent stream API while {@link ReadableStream.Source} and {@link WritableStream.Sink}
 * implementations provide the logic to connect a stream to specific data sources & sinks.
 */
export interface Source<T> {
    /**
     * Tells the source to prepare for providing chunks to the stream.  While the source may enqueue chunks at this
     * point, it is not required.
     *
     * @param controller The source can use the controller to enqueue chunks, close the stream or report an error.
     * @returns A promise that resolves when the source's start operation has finished.  If the promise rejects,
     * 		the stream will be errored.
     */
    start?(controller: ReadableStreamController<T>): Promise<void>;
    /**
     * Requests that source enqueue chunks.  Use the controller to close the stream when no more chunks can
     * be provided.
     *
     * @param controller The source can use the controller to enqueue chunks, close the stream or report an error.
     * @returns A promise that resolves when the source's pull operation has finished.  If the promise rejects,
     * 		the stream will be errored.
     */
    pull?(controller: ReadableStreamController<T>): Promise<void>;
    /**
     * Optional method implemented by seekable sources to set the seek position. Use the controller to report an error.
     * @param controller The source can use the controller to report an error.
     * @param position The position in the stream to seek to.
     * @returns A promise that resolves to the new seek position when the source's seek operation has finished.  If the
     *  	promise rejects, the stream will be errored.
     */
    seek?(controller: ReadableStreamController<T>, position: number): Promise<number>;
    /**
     * Indicates the stream is prematurely closing and allows the source to do any necessary clean up.
     *
     * @param reason The reason why the stream is closing.
     * @returns A promise that resolves when the source's pull operation has finished.  If the promise rejects,
     * 		the stream will be errored.
     */
    cancel?(reason?: any): Promise<void>;
}
/**
 * `ReadableStream`'s possible states
 */
export declare enum State {
    Readable = 0,
    Closed = 1,
    Errored = 2,
}
/**
 * Implementation of a readable stream.
 */
export default class ReadableStream<T> {
    protected readonly _allowPull: boolean;
    /**
     * Returns a number indicating how much additional data can be pushed by the source to the stream's queue before it
     * exceeds its `highWaterMark`. An underlying source should use this information to determine when and how to apply
     * backpressure.
     *
     * @returns The stream's strategy's `highWaterMark` value minus the queue size
     */
    readonly desiredSize: number;
    readonly hasSource: boolean;
    /**
     * A stream can only have one reader at a time. This value indicates if a stream already has a reader, and hence
     * cannot be read from other than by that reader. When a consumer is done with a reader they can dissociate it
     * by calling {@link ReadableStreamReader#releaseLock}.
     *
     * @returns True if the stream has a reader associated with it
     */
    readonly locked: boolean;
    readonly readable: boolean;
    /**
     * This promise will resolve when the stream's underlying source has started and is ready to provide data. If
     * the {@link ReadableStreamReader#read} method is called before the stream has started it will not do anything.
     * Wait for this promise to resolve to ensure that your `read` calls are responded to as promptly as possible.
     *
     * @returns A promise that resolves when the stream is ready to be read from.
     */
    readonly started: Promise<void>;
    readonly queueSize: number;
    protected _pullingPromise: Promise<void> | undefined;
    protected _started: boolean;
    protected _startedPromise: Promise<void>;
    protected _strategy: Strategy<T>;
    protected _underlyingSource: Source<T>;
    closeRequested: boolean;
    controller: ReadableStreamController<T>;
    pullScheduled: boolean;
    queue: SizeQueue<T>;
    reader: ReadableStreamReader<T> | undefined;
    state: State;
    storedError: Error;
    /**
     * A `ReadableStream` requires an underlying source to supply data. The source interacts with the stream through
     * a {@link ReadableStreamController} that is associated with the stream, and provided to the source.
     *
     * @constructor
     * @param underlyingSource The source object that supplies data to the stream by interacting with its controller.
     * @param strategy The strategy for this stream.
     */
    constructor(underlyingSource: Source<T>, strategy?: Strategy<T>);
    protected _cancel(reason?: any): Promise<void>;
    protected _shouldApplyBackPressure(): boolean;
    /**
     *
     * @param reason A description of the reason the stream is being canceled.
     * @returns A promise that resolves when the stream has closed and the call to the underlying source's `cancel`
     * method has completed.
     */
    cancel(reason?: any): Promise<void>;
    /**
     * Closes the stream without regard to the status of the queue.  Use {@link requestClose} to close the
     * stream and allow the queue to flush.
     *
     */
    close(): void;
    enqueue(chunk: T): void;
    error(error: Error): void;
    /**
     * create a new {@link ReadableStreamReader} and lock the stream to the new reader
     */
    getReader(): ReadableStreamReader<T>;
    pipeThrough(transformStream: TransformStream<T, any>, options?: PipeOptions): ReadableStream<T>;
    pipeTo(dest: WritableStream<T>, options?: PipeOptions): Promise<void>;
    pull(): void;
    /**
     * Requests the stream be closed.  This method allows the queue to be emptied before the stream closes.
     *
     */
    requestClose(): void;
    /**
     * Tee a readable stream, returning a two-element array containing
     * the two resulting ReadableStream instances
     */
    tee(): [ReadableStream<T>, ReadableStream<T>];
}
