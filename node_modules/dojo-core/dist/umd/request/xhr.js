(function (factory) {
    if (typeof module === 'object' && typeof module.exports === 'object') {
        var v = factory(require, exports); if (v !== undefined) module.exports = v;
    }
    else if (typeof define === 'function' && define.amd) {
        define(["require", "exports", '../async/Task', './errors/RequestTimeoutError', '../global', '../has', '../util', './util'], factory);
    }
})(function (require, exports) {
    "use strict";
    var Task_1 = require('../async/Task');
    var RequestTimeoutError_1 = require('./errors/RequestTimeoutError');
    var global_1 = require('../global');
    var has_1 = require('../has');
    var util_1 = require('../util');
    var util_2 = require('./util');
    /**
     * A lookup table for valid `XMLHttpRequest#responseType` values.
     *
     * 'json' deliberately excluded since it is not supported in all environments, and as there is
     * already a filter for it in '../request'. Default '' and 'text' values also deliberately excluded.
     */
    var responseTypeMap = {
        arraybuffer: 'arraybuffer',
        // XHR2 environments that do not support `responseType=blob` still support `responseType=arraybuffer`,
        // which is a better way of handling blob data than as a string representation.
        blob: has_1.default('xhr2-blob') ? 'blob' : 'arraybuffer',
        document: 'document'
    };
    /* a noop handle for cancelled requests */
    var noop = function () { };
    /**
     * Converts a string to an array buffer
     * @param str The string to convert
     */
    function stringToArrayBuffer(str) {
        var buf = new ArrayBuffer(str.length * 2);
        var bufView = new Uint8Array(buf);
        for (var i = 0; i < str.length; i++) {
            bufView[i] = str.charCodeAt(i);
        }
        return buf;
    }
    ;
    function xhr(url, options) {
        if (options === void 0) { options = {}; }
        var request = new XMLHttpRequest();
        var requestUrl = util_2.generateRequestUrl(url, options);
        var response = {
            data: null,
            nativeResponse: request,
            requestOptions: options,
            statusCode: null,
            statusText: null,
            url: requestUrl,
            getHeader: function (name) {
                return request.getResponseHeader(name);
            }
        };
        var isAborted = false;
        function abort() {
            isAborted = true;
            if (request) {
                request.abort();
                request.onreadystatechange = noop;
            }
        }
        var promise = new Task_1.default(function (resolve, reject) {
            if (!options.method) {
                options.method = 'GET';
            }
            if ((!options.user || !options.password) && options.auth) {
                var auth = options.auth.split(':');
                options.user = decodeURIComponent(auth[0]);
                options.password = decodeURIComponent(auth[1]);
            }
            request.open(options.method, requestUrl, !options.blockMainThread, options.user, options.password);
            if (has_1.default('xhr2') && options.responseType && options.responseType in responseTypeMap) {
                request.responseType = responseTypeMap[options.responseType];
            }
            var timeoutHandle;
            request.onreadystatechange = function () {
                if (!isAborted && request.readyState === 4) {
                    request.onreadystatechange = noop;
                    timeoutHandle && timeoutHandle.destroy();
                    if (options.responseType === 'xml') {
                        response.data = request.responseXML;
                    }
                    else {
                        response.data = ('response' in request) ? request.response : request.responseText;
                        /* Android 4 has a defect where it doesn't respect the responseType
                         * See https://github.com/dojo/core/issues/125 */
                        if (options.responseType === 'arraybuffer' && typeof response.data === 'string' && has_1.default('arraybuffer')) {
                            response.data = stringToArrayBuffer(response.data);
                        }
                    }
                    response.statusCode = request.status;
                    response.statusText = request.statusText;
                    if (response.statusCode > 0 && response.statusCode < 400) {
                        resolve(response);
                    }
                    else {
                        reject(response.statusText ?
                            new Error(response.statusText) :
                            new Error('An error prevented completion of the request.'));
                    }
                }
            };
            if (options.timeout > 0 && options.timeout !== Infinity) {
                timeoutHandle = util_1.createTimer(function () {
                    // Reject first, since aborting will also fire onreadystatechange which would reject with a
                    // less specific error.  (This is also why we set up our own timeout rather than using
                    // native timeout and ontimeout, because that aborts and fires onreadystatechange before ontimeout.)
                    reject(new RequestTimeoutError_1.default('The XMLHttpRequest request timed out.'));
                    abort();
                }, options.timeout);
            }
            var headers = options.headers;
            var hasContentTypeHeader = false;
            if (headers) {
                for (var header in headers) {
                    if (header.toLowerCase() === 'content-type') {
                        hasContentTypeHeader = true;
                    }
                    request.setRequestHeader(header, headers[header]);
                }
            }
            if (!headers || !('X-Requested-With' in headers)) {
                request.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
            }
            if (!hasContentTypeHeader && has_1.default('formdata') && options.data instanceof global_1.default.FormData) {
                // Assume that most forms do not contain large binary files. If that is not the case,
                // then "multipart/form-data" should be manually specified as the "Content-Type" header.
                request.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
            }
            if (options.responseType === 'xml' && request.overrideMimeType) {
                // This forces the XHR to parse the response as XML regardless of the MIME-type returned by the server
                request.overrideMimeType('text/xml');
            }
            request.send(options.data);
        }, function () {
            abort();
        });
        return promise;
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = xhr;
});
//# sourceMappingURL=xhr.js.map