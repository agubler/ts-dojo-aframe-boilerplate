import { Iterable } from 'dojo-shim/iterator';
import Promise, { Executor, State } from 'dojo-shim/Promise';
import { Thenable } from 'dojo-shim/interfaces';
export declare const Canceled: State;
/**
 * A type guard that determines if `value` is a `Task`
 * @param value The value to guard
 */
export declare function isTask<T>(value: any): value is Task<T>;
/**
 * Task is an extension of Promise that supports cancelation.
 */
export default class Task<T> extends Promise<T> {
    static all<T>(iterator: Iterable<(T | Thenable<T>)> | (T | Thenable<T>)[]): Task<T[]>;
    static race<T>(iterator: Iterable<(T | Thenable<T>)> | (T | Thenable<T>)[]): Task<T>;
    static reject<T>(reason: Error): Task<any>;
    static resolve(): Task<void>;
    static resolve<T>(value: (T | Thenable<T>)): Task<T>;
    protected static copy<U>(other: Promise<U>): Task<U>;
    constructor(executor: Executor<T>, canceler?: () => void);
    /**
     * A cancelation handler that will be called if this task is canceled.
     */
    private canceler;
    /**
     * Children of this Task (i.e., Tasks that were created from this Task with `then` or `catch`).
     */
    private children;
    /**
     * The finally callback for this Task (if it was created by a call to `finally`).
     */
    private _finally;
    /**
     * Propagates cancelation down through a Task tree. The Task's state is immediately set to canceled. If a Thenable
     * finally task was passed in, it is resolved before calling this Task's finally callback; otherwise, this Task's
     * finally callback is immediately executed. `_cancel` is called for each child Task, passing in the value returned
     * by this Task's finally callback or a Promise chain that will eventually resolve to that value.
     */
    private _cancel(finallyTask?);
    /**
     * Immediately cancels this task if it has not already resolved. This Task and any descendants are synchronously set
     * to the Canceled state and any `finally` added downstream from the canceled Task are invoked.
     */
    cancel(): void;
    finally(callback: () => void | Thenable<any>): Task<T>;
    then<U>(onFulfilled?: (value: T | undefined) => U | Thenable<U>, onRejected?: (error: Error | undefined) => U | Thenable<U>): Task<U>;
    catch<U>(onRejected: (reason?: Error) => (U | Thenable<U>)): Task<U>;
}
